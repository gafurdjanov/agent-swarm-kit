import * as di_scoped from 'di-scoped';
import * as functools_kit from 'functools-kit';
import { SortedArray, Subject } from 'functools-kit';

/**
 * Interface representing the context.
 */
interface IExecutionContext {
    clientId: string;
    executionId: string;
    processId: string;
}
/**
 * Service providing execution context information.
 */
declare const ExecutionContextService: (new () => {
    readonly context: IExecutionContext;
}) & Omit<{
    new (context: IExecutionContext): {
        readonly context: IExecutionContext;
    };
}, "prototype"> & di_scoped.IScopedClassRun<[context: IExecutionContext]>;

/**
 * Interface representing an incoming message received by the swarm system.
 * Encapsulates a message entering the system, typically from a client (e.g., user input), processed by agents (e.g., ClientAgent.execute) or sessions (e.g., ISession.connect).
 * Used to convey data from an external source to an agent, potentially triggering actions like history updates (e.g., IHistory.push) or event emissions (e.g., IBus.emit "commit-user-message").
 */
interface IIncomingMessage {
    /**
     * The unique identifier of the client sending the message.
     * Identifies the originating client session, matching clientId in runtime params (e.g., this.params.clientId in ClientAgent), ensuring the message is tied to a specific sender.
     * Example: "client-123" for a user session submitting a command.
     * @type {string}
     */
    clientId: string;
    /**
     * The content or payload of the incoming message.
     * Contains the raw data sent by the client, typically a string (e.g., user command, query), processed as input by agents (e.g., incoming in ClientAgent.execute).
     * Example: "What is the weather?" for a user query received by an agent.
     * @type {string}
     */
    data: string;
    /**
     * The name of the agent designated to receive or process the message.
     * Links the message to a specific agent instance (e.g., this.params.agentName in ClientAgent), aligning with AgentName from IAgentParams for routing or context.
     * Example: "WeatherAgent" for an agent handling weather-related queries.
     * @type {AgentName}
     */
    agentName: AgentName;
}
/**
 * Interface representing an outgoing message sent from the swarm system.
 * Encapsulates a message dispatched to a client, typically an agent’s response or output (e.g., ClientAgent._emitOutput), delivered via sessions (e.g., ISession.emit) or events (e.g., IBus.emit "emit-output").
 * Used to communicate results or notifications back to the client, reflecting the system’s response to incoming messages or internal actions.
 */
interface IOutgoingMessage {
    /**
     * The unique identifier of the client receiving the message.
     * Specifies the target client session, matching clientId in runtime params (e.g., this.params.clientId in ClientAgent), ensuring delivery to the intended recipient.
     * Example: "client-123" for a user session receiving a response.
     * @type {string}
     */
    clientId: string;
    /**
     * The content or payload of the outgoing message.
     * Contains the data sent to the client, typically a string (e.g., processed result, assistant response), generated by agents (e.g., result in ClientAgent._emitOutput).
     * Example: "The weather is sunny." for an agent’s response to a query.
     * @type {string}
     */
    data: string;
    /**
     * The name of the agent sending the message.
     * Identifies the originating agent instance (e.g., this.params.agentName in ClientAgent), aligning with AgentName from IAgentParams to indicate the source of the response.
     * Example: "WeatherAgent" for an agent replying to a client query.
     * @type {AgentName}
     */
    agentName: AgentName;
}

/**
 * Interface representing a logging mechanism for the swarm system.
 * Provides methods to record messages at different severity levels, used across components like agents, sessions, states, storage, swarms, history, embeddings, completions, and policies.
 * Logs are utilized to track lifecycle events (e.g., initialization, disposal), operational details (e.g., tool calls, message emissions), validation outcomes (e.g., policy checks), and errors (e.g., persistence failures), aiding in debugging, monitoring, and auditing.
 */
interface ILogger {
    /**
     * Logs a general-purpose message.
     * Used throughout the swarm system to record significant events or state changes, such as agent execution, session connections, or storage updates.
     * @param {string} topic - The category or context of the log message (e.g., "AgentExecution", "StorageUpsert").
     * @param {...any[]} args - Variable arguments representing the message content, which can include strings, objects, or other data types for flexible logging.
     */
    log(topic: string, ...args: any[]): void;
    /**
     * Logs a debug-level message.
     * Employed for detailed diagnostic information, such as intermediate states during agent tool calls, swarm navigation changes, or embedding creation processes, typically enabled in development or troubleshooting scenarios.
     * @param {string} topic - The category or context of the debug message (e.g., "ToolValidation", "EmbeddingSimilarity").
     * @param {...any[]} args - Variable arguments representing the debug content, often detailed data like parameters, stack traces, or internal states.
     */
    debug(topic: string, ...args: any[]): void;
    /**
     * Logs an info-level message.
     * Used to record informational updates, such as successful completions, policy validations, or history commits, providing a high-level overview of system activity without excessive detail.
     * @param {string} topic - The category or context of the info message (e.g., "SessionInit", "PolicyBan").
     * @param {...any[]} args - Variable arguments representing the informational content, typically concise summaries or status updates.
     */
    info(topic: string, ...args: any[]): void;
}

/**
 * Type representing an array of numbers as embeddings.
 * Used to encode text or data for similarity comparisons in storage or search operations.
 * @typedef {number[]} Embeddings
 */
type Embeddings = number[];
/**
 * Interface representing callbacks for embedding lifecycle events.
 * Provides hooks for creation and comparison of embeddings.
 */
interface IEmbeddingCallbacks {
    /**
     * Callback triggered when an embedding is created.
     * Useful for logging or post-processing the generated embeddings.
     * @param {string} text - The input text used to generate the embedding.
     * @param {Embeddings} embeddings - The resulting embedding as an array of numbers.
     * @param {string} clientId - The unique ID of the client associated with the embedding.
     * @param {EmbeddingName} embeddingName - The unique name of the embedding mechanism.
     */
    onCreate(text: string, embeddings: Embeddings, clientId: string, embeddingName: EmbeddingName): void;
    /**
     * Callback triggered when two embeddings are compared for similarity.
     * Useful for logging or analyzing similarity results.
     * @param {string} text1 - The first text whose embedding was used in the comparison.
     * @param {string} text2 - The second text whose embedding was used in the comparison.
     * @param {number} similarity - The similarity score between the two embeddings (e.g., cosine similarity).
     * @param {string} clientId - The unique ID of the client associated with the comparison.
     * @param {EmbeddingName} embeddingName - The unique name of the embedding mechanism.
     */
    onCompare(text1: string, text2: string, similarity: number, clientId: string, embeddingName: EmbeddingName): void;
}
/**
 * Interface representing the schema for configuring an embedding mechanism.
 * Defines how embeddings are created and compared within the swarm.
 */
interface IEmbeddingSchema {
    /** The unique name of the embedding mechanism within the swarm. */
    embeddingName: EmbeddingName;
    /**
     * Creates an embedding from the provided text.
     * Typically used for indexing or search operations in storage.
     * @param {string} text - The text to encode into an embedding.
     * @returns {Promise<Embeddings>} A promise resolving to the generated embedding as an array of numbers.
     * @throws {Error} If embedding creation fails (e.g., due to invalid text or model errors).
     */
    createEmbedding(text: string): Promise<Embeddings>;
    /**
     * Calculates the similarity between two embeddings.
     * Commonly used for search or ranking operations (e.g., cosine similarity).
     * @param {Embeddings} a - The first embedding to compare.
     * @param {Embeddings} b - The second embedding to compare.
     * @returns {Promise<number>} A promise resolving to the similarity score (typically between -1 and 1).
     * @throws {Error} If similarity calculation fails (e.g., due to invalid embeddings or computation errors).
     */
    calculateSimilarity(a: Embeddings, b: Embeddings): Promise<number>;
    /** Optional partial set of callbacks for embedding events, allowing customization of creation and comparison. */
    callbacks?: Partial<IEmbeddingCallbacks>;
}
/**
 * Type representing the unique name of an embedding mechanism within the swarm.
 * @typedef {string} EmbeddingName
 */
type EmbeddingName = string;

/**
 * Type representing the unique identifier for storage items.
 * @typedef {string | number} StorageId
 */
type StorageId = string | number;
/**
 * Interface representing the data structure stored in the storage.
 * Defines the minimum required properties for storage items.
 */
interface IStorageData {
    /** The unique identifier for the storage item, used for retrieval and removal. */
    id: StorageId;
}
/**
 * Interface representing the schema for storage configuration.
 * Defines how storage behaves, including persistence, indexing, and data access.
 * @template T - The type of the storage data, defaults to IStorageData.
 */
interface IStorageSchema<T extends IStorageData = IStorageData> {
    /** Optional flag to enable serialization of storage data to persistent storage (e.g., hard drive). */
    persist?: boolean;
    /** Optional description for documentation purposes, aiding in storage usage understanding. */
    docDescription?: string;
    /** Optional flag indicating whether the storage instance is shared across all agents for a client. */
    shared?: boolean;
    /**
     * Optional function to retrieve data from the storage, overriding default behavior.
     * @param {string} clientId - The unique ID of the client requesting the data.
     * @param {StorageName} storageName - The unique name of the storage.
     * @param {T[]} defaultValue - The default data to return if no data is found.
     * @returns {Promise<T[]> | T[]} The stored data, synchronously or asynchronously.
     */
    getData?: (clientId: string, storageName: StorageName, defaultValue: T[]) => Promise<T[]> | T[];
    /**
     * Optional function to persist storage data to the hard drive, overriding default behavior.
     * @param {T[]} data - The data to persist.
     * @param {string} clientId - The unique ID of the client updating the storage.
     * @param {StorageName} storageName - The unique name of the storage.
     * @returns {Promise<void> | void} A promise that resolves when data is persisted, or void if synchronous.
     * @throws {Error} If persistence fails (e.g., due to disk errors).
     */
    setData?: (data: T[], clientId: string, storageName: StorageName) => Promise<void> | void;
    /**
     * Function to generate an index for a storage item, used for search and retrieval.
     * @param {T} item - The storage item to index.
     * @returns {Promise<string> | string} The index string for the item, synchronously or asynchronously.
     */
    createIndex(item: T): Promise<string> | string;
    /** The name of the embedding mechanism used for indexing and searching storage data. */
    embedding: EmbeddingName;
    /** The unique name of the storage within the swarm. */
    storageName: StorageName;
    /** Optional partial set of lifecycle callbacks for storage events, allowing customization. */
    callbacks?: Partial<IStorageCallbacks<T>>;
    /**
     * Optional function to provide the default data for the storage, resolved in persistence logic.
     * @param {string} clientId - The unique ID of the client requesting the default data.
     * @param {StorageName} storageName - The unique name of the storage.
     * @returns {Promise<T[]> | T[]} The default data array, synchronously or asynchronously.
     */
    getDefaultData?: (clientId: string, storageName: StorageName) => Promise<T[]> | T[];
}
/**
 * Interface representing callbacks for storage lifecycle and operational events.
 * Provides hooks for updates, searches, initialization, and disposal.
 * @template T - The type of the storage data, defaults to IStorageData.
 */
interface IStorageCallbacks<T extends IStorageData = IStorageData> {
    /**
     * Callback triggered when storage data is updated (e.g., via upsert or remove).
     * Useful for logging or synchronizing state.
     * @param {T[]} items - The updated array of storage items.
     * @param {string} clientId - The unique ID of the client associated with the storage.
     * @param {StorageName} storageName - The unique name of the storage.
     */
    onUpdate: (items: T[], clientId: string, storageName: StorageName) => void;
    /**
     * Callback triggered during a search operation on the storage.
     * @param {string} search - The search query used to filter items.
     * @param {SortedArray<T>} index - The sorted array of storage items based on the search.
     * @param {string} clientId - The unique ID of the client performing the search.
     * @param {StorageName} storageName - The unique name of the storage.
     */
    onSearch: (search: string, index: SortedArray<T>, clientId: string, storageName: StorageName) => void;
    /**
     * Callback triggered when the storage is initialized.
     * Useful for setup or logging.
     * @param {string} clientId - The unique ID of the client associated with the storage.
     * @param {StorageName} storageName - The unique name of the storage.
     */
    onInit: (clientId: string, storageName: StorageName) => void;
    /**
     * Callback triggered when the storage is disposed of.
     * Useful for cleanup or logging.
     * @param {string} clientId - The unique ID of the client associated with the storage.
     * @param {StorageName} storageName - The unique name of the storage.
     */
    onDispose: (clientId: string, storageName: StorageName) => void;
}
/**
 * Interface representing the runtime parameters for storage management.
 * Extends the storage schema with client-specific and embedding-related dependencies.
 * @template T - The type of the storage data, defaults to IStorageData.
 * @extends {IStorageSchema<T>}
 * @extends {Partial<IEmbeddingCallbacks>}
 */
interface IStorageParams<T extends IStorageData = IStorageData> extends IStorageSchema<T>, Partial<IEmbeddingCallbacks> {
    /** The unique ID of the client associated with the storage instance. */
    clientId: string;
    /**
     * Function to calculate similarity between embeddings, inherited from the embedding schema.
     * Used for search operations.
     */
    calculateSimilarity: IEmbeddingSchema["calculateSimilarity"];
    /**
     * Function to create an embedding for storage items, inherited from the embedding schema.
     * Used for indexing.
     */
    createEmbedding: IEmbeddingSchema["createEmbedding"];
    /** The unique name of the storage within the swarm (redundant with schema but included for clarity). */
    storageName: StorageName;
    /** The logger instance for recording storage-related activity and errors. */
    logger: ILogger;
    /** The bus instance for event communication within the swarm. */
    bus: IBus;
}
/**
 * Interface representing the runtime storage management API.
 * Provides methods to manipulate and query storage data.
 * @template T - The type of the storage data, defaults to IStorageData.
 */
interface IStorage<T extends IStorageData = IStorageData> {
    /**
     * Retrieves a specified number of items from the storage based on a search query.
     * Uses embeddings for similarity-based retrieval.
     * @param {string} search - The search query to filter items.
     * @param {number} total - The maximum number of items to retrieve.
     * @param {number} [score] - Optional similarity score threshold for filtering items.
     * @returns {Promise<T[]>} A promise resolving to an array of matching storage items.
     * @throws {Error} If retrieval fails (e.g., due to embedding issues or invalid query).
     */
    take(search: string, total: number, score?: number): Promise<T[]>;
    /**
     * Inserts or updates an item in the storage.
     * Updates the index and persists data if configured.
     * @param {T} item - The item to upsert into the storage.
     * @returns {Promise<void>} A promise that resolves when the upsert operation is complete.
     * @throws {Error} If upsert fails (e.g., due to persistence issues or invalid item).
     */
    upsert(item: T): Promise<void>;
    /**
     * Removes an item from the storage by its ID.
     * Updates the index and persists changes if configured.
     * @param {IStorageData["id"]} itemId - The ID of the item to remove.
     * @returns {Promise<void>} A promise that resolves when the removal operation is complete.
     * @throws {Error} If removal fails (e.g., due to persistence issues or invalid ID).
     */
    remove(itemId: IStorageData["id"]): Promise<void>;
    /**
     * Retrieves an item from the storage by its ID.
     * @param {IStorageData["id"]} itemId - The ID of the item to retrieve.
     * @returns {Promise<T | null>} A promise resolving to the item if found, or null if not found.
     * @throws {Error} If retrieval fails (e.g., due to internal errors).
     */
    get(itemId: IStorageData["id"]): Promise<T | null>;
    /**
     * Lists all items in the storage, optionally filtered by a predicate.
     * @param {(item: T) => boolean} [filter] - Optional function to filter items; only items returning true are included.
     * @returns {Promise<T[]>} A promise resolving to an array of storage items.
     * @throws {Error} If listing fails (e.g., due to persistence issues).
     */
    list(filter?: (item: T) => boolean): Promise<T[]>;
    /**
     * Clears all items from the storage, resetting it to an empty state.
     * Persists changes if configured.
     * @returns {Promise<void>} A promise that resolves when the clear operation is complete.
     * @throws {Error} If clearing fails (e.g., due to persistence issues).
     */
    clear(): Promise<void>;
}
/**
 * Type representing the unique name of a storage within the swarm.
 * @typedef {string} StorageName
 */
type StorageName = string;

/**
 * Type representing the data structure of a state.
 * Can be any type, serving as a generic placeholder for state values.
 * @typedef {any} IStateData
 */
type IStateData = any;
/**
 * Interface representing a middleware function for state management.
 * Allows modification or validation of state during lifecycle operations.
 * @template T - The type of the state data, defaults to IStateData.
 */
interface IStateMiddleware<T extends IStateData = IStateData> {
    /**
     * Processes the state, potentially modifying it before it’s finalized.
     * @param {T} state - The current state data to process.
     * @param {string} clientId - The unique ID of the client associated with the state.
     * @param {StateName} stateName - The unique name of the state.
     * @returns {Promise<T>} A promise resolving to the updated state after middleware processing.
     * @throws {Error} If middleware processing fails or validation conditions are not met.
     */
    (state: T, clientId: string, stateName: StateName): Promise<T>;
}
/**
 * Interface representing callbacks for state lifecycle events.
 * Provides hooks for initialization, disposal, and state transitions.
 * @template T - The type of the state data, defaults to IStateData.
 */
interface IStateCallbacks<T extends IStateData = IStateData> {
    /**
     * Callback triggered when the state is initialized.
     * Useful for setup or logging.
     * @param {string} clientId - The unique ID of the client associated with the state.
     * @param {StateName} stateName - The unique name of the state.
     */
    onInit: (clientId: string, stateName: StateName) => void;
    /**
     * Callback triggered when the state is disposed of.
     * Useful for cleanup or logging.
     * @param {string} clientId - The unique ID of the client associated with the state.
     * @param {StateName} stateName - The unique name of the state.
     */
    onDispose: (clientId: string, stateName: StateName) => void;
    /**
     * Callback triggered when the state is loaded from storage or initialized.
     * @param {T} state - The loaded state data.
     * @param {string} clientId - The unique ID of the client associated with the state.
     * @param {StateName} stateName - The unique name of the state.
     */
    onLoad: (state: T, clientId: string, stateName: StateName) => void;
    /**
     * Callback triggered when the state is read.
     * Useful for monitoring or logging read operations.
     * @param {T} state - The current state data being read.
     * @param {string} clientId - The unique ID of the client associated with the state.
     * @param {StateName} stateName - The unique name of the state.
     */
    onRead: (state: T, clientId: string, stateName: StateName) => void;
    /**
     * Callback triggered when the state is written or updated.
     * Useful for tracking changes or triggering side effects.
     * @param {T} state - The updated state data being written.
     * @param {string} clientId - The unique ID of the client associated with the state.
     * @param {StateName} stateName - The unique name of the state.
     */
    onWrite: (state: T, clientId: string, stateName: StateName) => void;
}
/**
 * Interface representing the schema for state management.
 * Defines the configuration and behavior of a state within the swarm.
 * @template T - The type of the state data, defaults to IStateData.
 */
interface IStateSchema<T extends IStateData = IStateData> {
    /** Optional flag to enable serialization of state values to persistent storage (e.g., hard drive). */
    persist?: boolean;
    /** Optional description for documentation purposes, aiding in state usage understanding. */
    docDescription?: string;
    /** Optional flag indicating whether the state can be shared across multiple agents. */
    shared?: boolean;
    /** The unique name of the state within the swarm. */
    stateName: StateName;
    /**
     * Function to retrieve or compute the default state value.
     * @param {string} clientId - The unique ID of the client requesting the state.
     * @param {StateName} stateName - The unique name of the state.
     * @returns {T | Promise<T>} The default state value, synchronously or asynchronously.
     */
    getDefaultState: (clientId: string, stateName: StateName) => T | Promise<T>;
    /**
     * Optional function to retrieve the current state, with a fallback to the default state.
     * Overrides default state retrieval behavior if provided.
     * @param {string} clientId - The unique ID of the client requesting the state.
     * @param {StateName} stateName - The unique name of the state.
     * @param {T} defaultState - The default state value to use if no state is found.
     * @returns {T | Promise<T>} The current state value, synchronously or asynchronously.
     */
    getState?: (clientId: string, stateName: StateName, defaultState: T) => T | Promise<T>;
    /**
     * Optional function to set or update the state.
     * Overrides default state setting behavior if provided.
     * @param {T} state - The new state value to set.
     * @param {string} clientId - The unique ID of the client updating the state.
     * @param {StateName} stateName - The unique name of the state.
     * @returns {Promise<void> | void} A promise that resolves when the state is set, or void if synchronous.
     * @throws {Error} If the state update fails (e.g., due to persistence issues).
     */
    setState?: (state: T, clientId: string, stateName: StateName) => Promise<void> | void;
    /** Optional array of middleware functions to process the state during lifecycle operations. */
    middlewares?: IStateMiddleware<T>[];
    /** Optional partial set of lifecycle callbacks for the state, allowing customization of state events. */
    callbacks?: Partial<IStateCallbacks<T>>;
}
/**
 * Interface representing the runtime parameters for state management.
 * Extends the state schema with client-specific runtime dependencies.
 * @template T - The type of the state data, defaults to IStateData.
 * @extends {IStateSchema<T>}
 */
interface IStateParams<T extends IStateData = IStateData> extends IStateSchema<T> {
    /** The unique ID of the client associated with the state instance. */
    clientId: string;
    /** The logger instance for recording state-related activity and errors. */
    logger: ILogger;
    /** The bus instance for event communication within the swarm. */
    bus: IBus;
}
/**
 * Interface representing the runtime state management API.
 * Provides methods to get, set, and clear the state.
 * @template T - The type of the state data, defaults to IStateData.
 */
interface IState<T extends IStateData = IStateData> {
    /**
     * Retrieves the current state value.
     * Applies any configured middleware or custom `getState` logic from the schema.
     * @returns {Promise<T>} A promise resolving to the current state value.
     * @throws {Error} If state retrieval fails (e.g., due to persistence issues or invalid configuration).
     */
    getState: () => Promise<T>;
    /**
     * Updates the state using a dispatch function that computes the new state from the previous state.
     * Applies any configured middleware or custom `setState` logic from the schema.
     * @param {(prevState: T) => Promise<T>} dispatchFn - An async function that takes the previous state and returns the new state.
     * @returns {Promise<T>} A promise resolving to the updated state value.
     * @throws {Error} If state update fails (e.g., due to middleware errors or persistence issues).
     */
    setState: (dispatchFn: (prevState: T) => Promise<T>) => Promise<T>;
    /**
     * Resets the state to its initial default value.
     * Reverts to the value provided by `getDefaultState` in the schema.
     * @returns {Promise<T>} A promise resolving to the initial state value.
     * @throws {Error} If state clearing fails (e.g., due to persistence issues or invalid default state).
     */
    clearState: () => Promise<T>;
}
/**
 * Type representing the unique name of a state within the swarm.
 * @typedef {string} StateName
 */
type StateName = string;

/**
 * Interface representing callbacks for policy lifecycle and validation events.
 * Provides hooks for initialization, validation, and ban actions.
 */
interface IPolicyCallbacks {
    /**
     * Optional callback triggered when the policy is initialized.
     * Useful for setup or logging.
     * @param {PolicyName} policyName - The unique name of the policy.
     */
    onInit?: (policyName: PolicyName) => void;
    /**
     * Optional callback triggered to validate incoming messages.
     * Useful for logging or monitoring input validation.
     * @param {string} incoming - The incoming message to validate.
     * @param {SessionId} clientId - The unique session ID of the client sending the message.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @param {PolicyName} policyName - The unique name of the policy.
     */
    onValidateInput?: (incoming: string, clientId: SessionId, swarmName: SwarmName, policyName: PolicyName) => void;
    /**
     * Optional callback triggered to validate outgoing messages.
     * Useful for logging or monitoring output validation.
     * @param {string} outgoing - The outgoing message to validate.
     * @param {SessionId} clientId - The unique session ID of the client receiving the message.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @param {PolicyName} policyName - The unique name of the policy.
     */
    onValidateOutput?: (outgoing: string, clientId: SessionId, swarmName: SwarmName, policyName: PolicyName) => void;
    /**
     * Optional callback triggered when a client is banned.
     * Useful for logging or triggering ban-related actions.
     * @param {SessionId} clientId - The unique session ID of the banned client.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @param {PolicyName} policyName - The unique name of the policy.
     */
    onBanClient?: (clientId: SessionId, swarmName: SwarmName, policyName: PolicyName) => void;
    /**
     * Optional callback triggered when a client is unbanned.
     * Useful for logging or triggering unban-related actions.
     * @param {SessionId} clientId - The unique session ID of the unbanned client.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @param {PolicyName} policyName - The unique name of the policy.
     */
    onUnbanClient?: (clientId: SessionId, swarmName: SwarmName, policyName: PolicyName) => void;
}
/**
 * Interface representing a policy enforcement mechanism.
 * Manages client bans and validates input/output messages within the swarm.
 */
interface IPolicy {
    /**
     * Checks if a client is currently banned under this policy.
     * @param {SessionId} clientId - The unique session ID of the client to check.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<boolean>} A promise resolving to true if the client is banned, false otherwise.
     * @throws {Error} If the ban status check fails (e.g., due to storage issues).
     */
    hasBan(clientId: SessionId, swarmName: SwarmName): Promise<boolean>;
    /**
     * Retrieves the ban message for a banned client.
     * @param {SessionId} clientId - The unique session ID of the banned client.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<string>} A promise resolving to the ban message for the client.
     * @throws {Error} If retrieving the ban message fails (e.g., due to missing configuration).
     */
    getBanMessage(clientId: SessionId, swarmName: SwarmName): Promise<string>;
    /**
     * Validates an incoming message against the policy rules.
     * @param {string} incoming - The incoming message to validate.
     * @param {SessionId} clientId - The unique session ID of the client sending the message.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<boolean>} A promise resolving to true if the input is valid, false otherwise.
     * @throws {Error} If validation fails unexpectedly (e.g., due to internal errors).
     */
    validateInput(incoming: string, clientId: SessionId, swarmName: SwarmName): Promise<boolean>;
    /**
     * Validates an outgoing message against the policy rules.
     * @param {string} outgoing - The outgoing message to validate.
     * @param {SessionId} clientId - The unique session ID of the client receiving the message.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<boolean>} A promise resolving to true if the output is valid, false otherwise.
     * @throws {Error} If validation fails unexpectedly (e.g., due to internal errors).
     */
    validateOutput(outgoing: string, clientId: SessionId, swarmName: SwarmName): Promise<boolean>;
    /**
     * Bans a client under this policy, adding them to the banned list.
     * @param {SessionId} clientId - The unique session ID of the client to ban.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<void>} A promise that resolves when the client is banned.
     * @throws {Error} If banning the client fails (e.g., due to persistence issues).
     */
    banClient(clientId: SessionId, swarmName: SwarmName): Promise<void>;
    /**
     * Unbans a client under this policy, removing them from the banned list.
     * @param {SessionId} clientId - The unique session ID of the client to unban.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<void>} A promise that resolves when the client is unbanned.
     * @throws {Error} If unbanning the client fails (e.g., due to persistence issues).
     */
    unbanClient(clientId: SessionId, swarmName: SwarmName): Promise<void>;
}
/**
 * Interface representing the schema for configuring a policy.
 * Defines how policies enforce rules and manage bans within the swarm.
 */
interface IPolicySchema {
    /** Optional description for documentation purposes, aiding in policy usage understanding. */
    docDescription?: string;
    /** The unique name of the policy within the swarm. */
    policyName: PolicyName;
    /** Optional default message to display when a client is banned, overridden by getBanMessage if provided. */
    banMessage?: string;
    /** Optional flag to automatically ban a client immediately after failed validation. */
    autoBan?: boolean;
    /**
     * Optional function to retrieve a custom ban message for a client.
     * Overrides the default banMessage if provided.
     * @param {SessionId} clientId - The unique session ID of the banned client.
     * @param {PolicyName} policyName - The unique name of the policy.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<string | null> | string | null} The ban message or null, synchronously or asynchronously.
     */
    getBanMessage?: (clientId: SessionId, policyName: PolicyName, swarmName: SwarmName) => Promise<string | null> | string | null;
    /**
     * Retrieves the list of currently banned clients under this policy.
     * @param {PolicyName} policyName - The unique name of the policy.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {SessionId[] | Promise<SessionId[]>} An array of banned session IDs, synchronously or asynchronously.
     */
    getBannedClients: (policyName: PolicyName, swarmName: SwarmName) => SessionId[] | Promise<SessionId[]>;
    /**
     * Optional function to set the list of banned clients.
     * Overrides default ban list management if provided.
     * @param {SessionId[]} clientIds - An array of session IDs to ban.
     * @param {PolicyName} policyName - The unique name of the policy.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<void> | void} A promise that resolves when the ban list is updated, or void if synchronous.
     * @throws {Error} If updating the ban list fails (e.g., due to persistence issues).
     */
    setBannedClients?: (clientIds: SessionId[], policyName: PolicyName, swarmName: SwarmName) => Promise<void> | void;
    /**
     * Optional function to validate incoming messages against custom policy rules.
     * Overrides default validation if provided.
     * @param {string} incoming - The incoming message to validate.
     * @param {SessionId} clientId - The unique session ID of the client sending the message.
     * @param {PolicyName} policyName - The unique name of the policy.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<boolean> | boolean} True if the input is valid, false otherwise, synchronously or asynchronously.
     */
    validateInput?: (incoming: string, clientId: SessionId, policyName: PolicyName, swarmName: SwarmName) => Promise<boolean> | boolean;
    /**
     * Optional function to validate outgoing messages against custom policy rules.
     * Overrides default validation if provided.
     * @param {string} outgoing - The outgoing message to validate.
     * @param {SessionId} clientId - The unique session ID of the client receiving the message.
     * @param {PolicyName} policyName - The unique name of the policy.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<boolean> | boolean} True if the output is valid, false otherwise, synchronously or asynchronously.
     */
    validateOutput?: (outgoing: string, clientId: SessionId, policyName: PolicyName, swarmName: SwarmName) => Promise<boolean> | boolean;
    /** Optional set of callbacks for policy events, allowing customization of validation and ban actions. */
    callbacks?: IPolicyCallbacks;
}
/**
 * Interface representing the parameters required to initialize a policy.
 * Extends the policy schema with runtime dependencies and full callback support.
 * @extends {IPolicySchema}
 * @extends {IPolicyCallbacks}
 */
interface IPolicyParams extends IPolicySchema, IPolicyCallbacks {
    /** The logger instance for recording policy-related activity and errors. */
    logger: ILogger;
    /** The bus instance for event communication within the swarm. */
    bus: IBus;
}
/**
 * Type representing the unique name of a policy within the swarm.
 * @typedef {string} PolicyName
 */
type PolicyName = string;

/**
 * Interface representing the contextual metadata for an event in the swarm system.
 * Provides optional identifiers for components involved in an event (e.g., agent, swarm, storage), used partially in IBusEvent.context to supply additional context.
 * In ClientAgent, typically only agentName is populated (e.g., context: { agentName }), with other fields available for broader system use (e.g., swarm or policy events).
 */
interface IBusEventContext {
    /**
     * The unique name of the agent associated with the event.
     * Links the event to a specific agent instance (e.g., this.params.agentName in ClientAgent), consistently included in IBusEvent.context.
     * Example: "Agent1" for an agent emitting a "run" event.
     * @type {AgentName}
     */
    agentName: AgentName;
    /**
     * The unique name of the swarm associated with the event.
     * Identifies the swarm context, potentially used in swarm-wide events (e.g., IBus.emit in ISwarmParams), though not observed in ClientAgent.
     * Example: "SwarmA" for a swarm-level navigation event.
     * @type {SwarmName}
     */
    swarmName: SwarmName;
    /**
     * The unique name of the storage associated with the event.
     * Ties the event to a specific storage instance (e.g., IStorage), potentially for storage-related events, unused in ClientAgent’s agent-centric emissions.
     * Example: "Storage1" for a storage upsert event.
     * @type {StorageName}
     */
    storageName: StorageName;
    /**
     * The unique name of the state associated with the event.
     * Links to a specific state instance (e.g., IState), potentially for state change events, not populated in ClientAgent’s context.
     * Example: "StateX" for a state update event.
     * @type {StateName}
     */
    stateName: StateName;
    /**
     * The unique name of the policy associated with the event.
     * Identifies the policy context (e.g., IPolicy), potentially for policy enforcement events (e.g., bans), unused in ClientAgent’s emissions.
     * Example: "PolicyY" for a client ban event.
     * @type {PolicyName}
     */
    policyName: PolicyName;
}
/**
 * Type representing the possible sources of an event in the swarm system.
 * A generic string identifier for the event’s origin, used in IBaseEvent.source and overridden by EventBusSource in IBusEvent for specific bus-related sources.
 * Example: "custom-source" for a generic event, though typically refined by EventBusSource in practice.
 * @typedef {string} EventSource
 */
type EventSource = string;
/**
 * Type representing specific sources of events for the internal bus in the swarm system.
 * Enumerates predefined origins for IBusEvent.source, observed as "agent-bus" in ClientAgent (e.g., bus.emit calls), with other values likely used in corresponding components (e.g., "history-bus" in IHistory).
 * @typedef {"agent-bus" | "history-bus" | "session-bus" | "state-bus" | "storage-bus" | "swarm-bus" | "execution-bus" | "policy-bus"} EventBusSource
 */
type EventBusSource = "agent-bus" | "history-bus" | "session-bus" | "state-bus" | "storage-bus" | "swarm-bus" | "execution-bus" | "policy-bus";
/**
 * Interface representing the base structure of an event in the swarm system.
 * Defines the minimal required fields for all events, extended by IBusEvent and ICustomEvent for specific use cases, and used generically in IBus.emit<T>.
 * Provides a foundation for event-driven communication across components like agents, sessions, and swarms.
 */
interface IBaseEvent {
    /**
     * The source of the event, identifying its origin within the system.
     * A generic string (EventSource) in IBaseEvent, overridden by EventBusSource in IBusEvent (e.g., "agent-bus" in ClientAgent).
     * Example: "custom-source" for a basic event, or "agent-bus" in practice.
     * @type {EventSource}
     */
    source: EventSource;
    /**
     * The unique identifier of the client targeted by the event.
     * Matches the clientId used in runtime params (e.g., this.params.clientId in ClientAgent), ensuring events reach the intended session or agent instance.
     * Example: "client-123" for a user session receiving an "emit-output" event.
     * @type {string}
     */
    clientId: string;
}
/**
 * Interface representing a structured event for the internal bus in the swarm system.
 * Extends IBaseEvent with a specific schema, used extensively in ClientAgent’s bus.emit calls (e.g., "run", "commit-user-message") to notify the system of actions, outputs, or state changes.
 * Dispatched via IBus.emit<IBusEvent> to broadcast detailed, agent-driven events with input/output data and context.
 */
interface IBusEvent extends Omit<IBaseEvent, keyof {
    source: never;
}> {
    /**
     * The specific source of the event, restricted to EventBusSource values.
     * Identifies the component emitting the event, consistently "agent-bus" in ClientAgent (e.g., RUN_FN, _emitOutput), with other values for other buses (e.g., "history-bus").
     * Example: "agent-bus" for an agent’s "emit-output" event.
     * @type {EventBusSource}
     */
    source: EventBusSource;
    /**
     * The type of the event, defining its purpose or action.
     * A string identifier unique to the event’s intent, observed in ClientAgent as "run", "emit-output", "commit-user-message", etc.
     * Example: "commit-tool-output" for a tool execution result.
     * @type {string}
     */
    type: string;
    /**
     * The input data for the event, as a key-value object.
     * Carries event-specific input (e.g., { message } in "commit-user-message", { mode, rawResult } in "emit-output" from ClientAgent), often tied to IModelMessage content.
     * Example: { toolId: "tool-xyz", content: "result" } for a tool output event.
     * @type {Record<string, any>}
     */
    input: Record<string, any>;
    /**
     * The output data for the event, as a key-value object.
     * Contains event-specific results (e.g., { result } in "run" or "emit-output" from ClientAgent), often empty {} for notifications (e.g., "commit-flush").
     * Example: { result: "processed data" } for an execution output.
     * @type {Record<string, any>}
     */
    output: Record<string, any>;
    /**
     * The contextual metadata for the event, partially implementing IBusEventContext.
     * Typically includes only agentName in ClientAgent (e.g., { agentName: this.params.agentName }), with other fields optional for broader use cases.
     * Example: { agentName: "Agent1" } for an agent-driven event.
     * @type {Partial<IBusEventContext>}
     */
    context: Partial<IBusEventContext>;
}
/**
 * Interface representing a custom event with a flexible payload in the swarm system.
 * Extends IBaseEvent for generic event handling, allowing arbitrary data via payload, though not directly observed in ClientAgent (which uses IBusEvent).
 * Likely used for bespoke event scenarios outside the structured IBusEvent schema, dispatched via IBus.emit<ICustomEvent>.
 */
interface ICustomEvent<T extends any = any> extends IBaseEvent {
    /**
     * The optional payload of the event, carrying custom data of any type.
     * Provides flexibility for event-specific information, unlike IBusEvent’s rigid input/output structure, potentially for user-defined events.
     * Example: { status: "complete", data: 42 } for a custom completion event.
     * @type {T | undefined}
     * @template T - The type of the payload, defaulting to any for maximum flexibility.
     */
    payload?: T;
}

/**
 * Interface representing an event bus for the swarm system.
 * Provides a mechanism for asynchronous, client-targeted event dispatching, primarily used by agents (e.g., ClientAgent) to broadcast operational updates, lifecycle changes, and outputs to the system.
 * Integrated into runtime parameters (e.g., IAgentParams, ISessionParams), the bus ensures decoupled communication between components, such as notifying clients of message commits, tool outputs, or execution results.
 */
interface IBus {
    /**
     * Emits a structured event to a specific client within the swarm system.
     * Asynchronously dispatches events to the designated `clientId`, enabling agents to notify the system of actions like message commits, tool executions, or output emissions.
     * Events follow a consistent schema extending IBaseEvent, including `type` (event identifier), `source` (originator, typically "agent-bus"), `input` (input data), `output` (result data), `context` (metadata with agentName), and `clientId` (redundant target ID).
     *
     * **Observed Behavior (from ClientAgent):**
     * - **Event Dispatch**: Events are emitted after significant actions, such as completing a stateless run (`"run"`), emitting validated output (`"emit-output"`), or committing messages/tools (`"commit-*"`).
     * - **Structure**: Every event includes a fixed set of fields, e.g.:
     *   ```javascript
     *   await this.params.bus.emit<IBusEvent>(this.params.clientId, {
     *     type: "commit-user-message",
     *     source: "agent-bus",
     *     input: { message },
     *     output: {},
     *     context: { agentName: this.params.agentName },
     *     clientId: this.params.clientId,
     *   });
     *   ```
     *   This notifies the system of a user message commit, with no output expected.
     * - **Asynchronous Delivery**: Returns a promise, implying events are queued or sent over a channel (e.g., network, in-memory queue), resolving when dispatched.
     * - **Client Targeting**: Always targets the client’s session ID (e.g., `this.params.clientId`), ensuring precise delivery to the intended recipient.
     * - **Notification Focus**: Primarily used for one-way notifications (e.g., history updates, tool stops), with `output` often empty unless carrying results (e.g., `"run"`, `"emit-output"`).
     *
     * **Example Usage in ClientAgent:**
     * - **Stateless Completion**:
     *   ```javascript
     *   await this.params.bus.emit<IBusEvent>(this.params.clientId, {
     *     type: "run",
     *     source: "agent-bus",
     *     input: { message },
     *     output: { result },
     *     context: { agentName: this.params.agentName },
     *     clientId: this.params.clientId,
     *   });
     *   ```
     *   Signals a completed stateless run with the transformed result.
     * - **Output Emission**:
     *   ```javascript
     *   await this.params.bus.emit<IBusEvent>(this.params.clientId, {
     *     type: "emit-output",
     *     source: "agent-bus",
     *     input: { mode, rawResult },
     *     output: { result },
     *     context: { agentName: this.params.agentName },
     *     clientId: this.params.clientId,
     *   });
     *   ```
     *   Broadcasts the final output after validation.
     *
     * **Key Characteristics:**
     * - **Redundancy**: The `clientId` in the event mirrors the emit target, aiding downstream filtering or validation.
     * - **Type Safety**: Generic `<T>` ensures events conform to IBaseEvent extensions (e.g., IBusEvent), supporting structured payloads.
     * - **Integration**: Paired with history updates (e.g., `history.push`) and callbacks (e.g., `onOutput`), amplifying system-wide awareness.
     *
     * @template T - The type of event, extending IBaseEvent, defining a structured payload with fields like `type`, `source`, `input`, `output`, `context`, and `clientId`.
     * @param {string} clientId - The unique identifier of the client to receive the event, typically the session ID from runtime params (e.g., `this.params.clientId` in ClientAgent).
     * @param {T} event - The event object to emit, a structured payload with mandatory fields (e.g., `{ type: "run", source: "agent-bus", input: { message } }`) specific to the action being notified.
     * @returns {Promise<void>} A promise that resolves when the event is successfully dispatched to the client’s event handling system, indicating completion of the emission process.
     * @throws {Error} If emission fails, potentially due to invalid `clientId`, malformed event structure, or delivery issues (e.g., queue overflow, network failure).
     */
    emit<T extends IBaseEvent>(clientId: string, event: T): Promise<void>;
}

/**
 * Interface representing callbacks for session-related events within a swarm.
 * Provides hooks for connection, execution, and emission events.
 */
interface ISwarmSessionCallbacks {
    /**
     * Optional callback triggered when a client connects to the swarm.
     * Useful for logging or initialization tasks.
     * @param {string} clientId - The unique ID of the client connecting.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     */
    onConnect?: (clientId: string, swarmName: SwarmName) => void;
    /**
     * Optional callback triggered when a command is executed within the swarm.
     * @param {string} clientId - The unique ID of the client executing the command.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @param {string} content - The content of the command to execute.
     * @param {ExecutionMode} mode - The source of execution ("tool" or "user").
     */
    onExecute?: (clientId: string, swarmName: SwarmName, content: string, mode: ExecutionMode) => void;
    /**
     * Optional callback triggered when a stateless completion run is executed.
     * @param {string} clientId - The unique ID of the client initiating the run.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @param {string} content - The content to process statelessly.
     */
    onRun?: (clientId: string, swarmName: SwarmName, content: string) => void;
    /**
     * Optional callback triggered when a message is emitted from the swarm.
     * @param {string} clientId - The unique ID of the client associated with the emission.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @param {string} message - The message content being emitted.
     */
    onEmit?: (clientId: string, swarmName: SwarmName, message: string) => void;
    /**
     * Optional callback triggered when a session is initialized within the swarm.
     * @param {string} clientId - The unique ID of the client associated with the session.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     */
    onInit?: (clientId: string, swarmName: SwarmName) => void;
    /**
     * Optional callback triggered when a session is disconnected or disposed of.
     * Note: "disponnected" in original comment corrected to "disconnected".
     * @param {string} clientId - The unique ID of the client associated with the session.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     */
    onDispose?: (clientId: string, swarmName: SwarmName) => void;
}
/**
 * Interface representing lifecycle callbacks for an initialized swarm.
 * Extends session callbacks with agent-specific navigation events.
 * @extends {ISwarmSessionCallbacks}
 */
interface ISwarmCallbacks extends ISwarmSessionCallbacks {
    /**
     * Callback triggered when the active agent changes within the swarm.
     * Useful for navigation tracking or state updates.
     * @param {string} clientId - The unique ID of the client associated with the change.
     * @param {AgentName} agentName - The name of the new active agent.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<void>} A promise that resolves when the agent change is processed.
     */
    onAgentChanged: (clientId: string, agentName: AgentName, swarmName: SwarmName) => Promise<void>;
}
/**
 * Interface representing the parameters required to initialize a swarm.
 * Extends the swarm schema (excluding certain fields) with runtime dependencies.
 * @extends {Omit<ISwarmSchema, "agentList" | "onAgentChanged">}
 */
interface ISwarmParams extends Omit<ISwarmSchema, keyof {
    agentList: never;
    onAgentChanged: never;
}> {
    /** The unique identifier of the client initializing the swarm. */
    clientId: string;
    /** The logger instance for recording swarm-related activity and errors. */
    logger: ILogger;
    /** The bus instance for event communication within the swarm. */
    bus: IBus;
    /** A map of agent names to their corresponding agent instances for runtime access. */
    agentMap: Record<AgentName, IAgent>;
}
/**
 * Interface representing the schema for defining a swarm.
 * Configures the swarm's behavior, navigation, and agent management.
 */
interface ISwarmSchema {
    /** Optional flag to enable serialization of navigation stack and active agent state to persistent storage (e.g., hard drive). */
    persist?: boolean;
    /** Optional description for documentation purposes, aiding in swarm usage understanding. */
    docDescription?: string;
    /** Optional array of policy names defining banhammer or access control rules for the swarm. */
    policies?: PolicyName[];
    /**
     * Optional function to retrieve the initial navigation stack after swarm initialization.
     * @param {string} clientId - The unique ID of the client requesting the stack.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<AgentName[]> | AgentName[]} The navigation stack, synchronously or asynchronously.
     */
    getNavigationStack?: (clientId: string, swarmName: SwarmName) => Promise<AgentName[]> | AgentName[];
    /**
     * Optional function to persist the navigation stack after a change.
     * @param {string} clientId - The unique ID of the client updating the stack.
     * @param {AgentName[]} navigationStack - The updated navigation stack.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<void>} A promise that resolves when the stack is persisted.
     * @throws {Error} If persistence fails (e.g., due to storage issues).
     */
    setNavigationStack?: (clientId: string, navigationStack: AgentName[], swarmName: SwarmName) => Promise<void>;
    /**
     * Optional function to fetch the active agent upon swarm initialization.
     * @param {string} clientId - The unique ID of the client requesting the agent.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @param {AgentName} defaultAgent - The default agent name to fall back to if no active agent is set.
     * @returns {Promise<AgentName> | AgentName} The name of the active agent, synchronously or asynchronously.
     */
    getActiveAgent?: (clientId: string, swarmName: SwarmName, defaultAgent: AgentName) => Promise<AgentName> | AgentName;
    /**
     * Optional function to update the active agent after navigation changes.
     * @param {string} clientId - The unique ID of the client updating the agent.
     * @param {AgentName} agentName - The name of the new active agent.
     * @param {SwarmName} swarmName - The unique name of the swarm.
     * @returns {Promise<void> | void} A promise that resolves when the agent is updated, or void if synchronous.
     * @throws {Error} If the update fails (e.g., due to persistence issues).
     */
    setActiveAgent?: (clientId: string, agentName: AgentName, swarmName: SwarmName) => Promise<void> | void;
    /** The default agent name to use when no active agent is specified. */
    defaultAgent: AgentName;
    /** The unique name of the swarm within the system. */
    swarmName: string;
    /** The list of agent names available within the swarm. */
    agentList: string[];
    /** Optional partial set of lifecycle callbacks for the swarm, allowing customization of events. */
    callbacks?: Partial<ISwarmCallbacks>;
}
/**
 * Interface representing a swarm of agents.
 * Provides methods for navigation, agent management, and output handling.
 */
interface ISwarm {
    /**
     * Removes and returns the most recent agent from the navigation stack, or falls back to the default agent.
     * @returns {Promise<AgentName>} A promise resolving to the agent name popped from the stack or the default agent.
     * @throws {Error} If navigation retrieval fails (e.g., due to persistence issues).
     */
    navigationPop(): Promise<AgentName>;
    /**
     * Cancels the current output operation, resulting in an empty string from waitForOutput.
     * @returns {Promise<void>} A promise that resolves when the output is canceled.
     * @throws {Error} If cancellation fails (e.g., due to internal errors).
     */
    cancelOutput(): Promise<void>;
    /**
     * Waits for and retrieves the output from the swarm’s active agent.
     * @returns {Promise<string>} A promise resolving to the output string from the swarm.
     * @throws {Error} If no output is available or waiting times out.
     */
    waitForOutput(): Promise<string>;
    /**
     * Retrieves the name of the currently active agent in the swarm.
     * @returns {Promise<AgentName>} A promise resolving to the name of the active agent.
     * @throws {Error} If the active agent cannot be determined (e.g., due to persistence issues).
     */
    getAgentName(): Promise<AgentName>;
    /**
     * Retrieves the instance of the currently active agent in the swarm.
     * @returns {Promise<IAgent>} A promise resolving to the active agent instance.
     * @throws {Error} If the agent instance cannot be retrieved (e.g., due to invalid agent name).
     */
    getAgent(): Promise<IAgent>;
    /**
     * Registers or updates an agent reference in the swarm’s agent map.
     * @param {AgentName} agentName - The name of the agent to register.
     * @param {IAgent} agent - The agent instance to associate with the name.
     * @returns {Promise<void>} A promise that resolves when the agent reference is set.
     * @throws {Error} If registration fails (e.g., due to invalid agent or internal errors).
     */
    setAgentRef(agentName: AgentName, agent: IAgent): Promise<void>;
    /**
     * Sets the active agent in the swarm by name, updating navigation if applicable.
     * @param {AgentName} agentName - The name of the agent to set as active.
     * @returns {Promise<void>} A promise that resolves when the active agent is updated.
     * @throws {Error} If setting the agent fails (e.g., due to persistence issues or invalid name).
     */
    setAgentName(agentName: AgentName): Promise<void>;
}
/**
 * Type representing the unique name of a swarm within the system.
 * @typedef {string} SwarmName
 */
type SwarmName = string;

/**
 * Interface representing the parameters required to create a session.
 * Combines session schema, swarm callbacks, and runtime dependencies.
 * @extends {ISessionSchema}
 * @extends {ISwarmSessionCallbacks}
 */
interface ISessionParams extends ISessionSchema, ISwarmSessionCallbacks {
    /** The unique ID of the client associated with the session. */
    clientId: string;
    /** The logger instance for recording session activity and errors. */
    logger: ILogger;
    /** The policy instance defining session rules and constraints. */
    policy: IPolicy;
    /** The bus instance for event communication within the swarm. */
    bus: IBus;
    /** The swarm instance managing the session. */
    swarm: ISwarm;
    /** The unique name of the swarm this session belongs to. */
    swarmName: SwarmName;
}
/**
 * Interface representing the schema for session data.
 * Currently empty, serving as a placeholder for future session-specific configuration.
 */
interface ISessionSchema {
}
/**
 * Type representing a function for sending messages.
 * @template T - The return type of the send operation, defaults to void.
 * @param {IOutgoingMessage} outgoing - The outgoing message to send.
 * @returns {Promise<T> | T} A promise resolving to the result of the send operation, or the result directly.
 */
type SendMessageFn$1<T = void> = (outgoing: IOutgoingMessage) => Promise<T>;
/**
 * Type representing a function for receiving messages.
 * @template T - The return type of the receive operation, defaults to void.
 * @param {IIncomingMessage} incoming - The incoming message to process.
 * @returns {Promise<T> | T} A promise resolving to the result of the receive operation, or the result directly.
 */
type ReceiveMessageFn<T = void> = (incoming: IIncomingMessage) => Promise<T>;
/**
 * Interface representing a session within the swarm.
 * Defines methods for message emission, execution, and state management.
 */
interface ISession {
    /**
     * Emits a message to the session's communication channel.
     * @param {string} message - The message content to emit.
     * @returns {Promise<void>} A promise that resolves when the message is successfully emitted.
     * @throws {Error} If the emission fails due to connection issues or invalid message format.
     */
    emit(message: string): Promise<void>;
    /**
     * Runs a stateless completion without modifying the session's chat history.
     * Useful for one-off computations or previews.
     * @param {string} content - The content to process statelessly.
     * @returns {Promise<string>} A promise resolving to the output of the completion.
     * @throws {Error} If the execution fails due to invalid content or internal errors.
     */
    run(content: string): Promise<string>;
    /**
     * Executes a command within the session, potentially updating history based on mode.
     * @param {string} content - The content to execute.
     * @param {ExecutionMode} mode - The source of execution ("tool" or "user").
     * @returns {Promise<string>} A promise resolving to the output of the execution.
     * @throws {Error} If the execution fails due to invalid content, mode, or internal errors.
     */
    execute(content: string, mode: ExecutionMode): Promise<string>;
    /**
     * Connects the session to a message sender and returns a receiver function.
     * Establishes a bidirectional communication channel.
     * @param {SendMessageFn} connector - The function to send outgoing messages.
     * @param {...unknown[]} args - Additional arguments for connector setup (implementation-specific).
     * @returns {ReceiveMessageFn<string>} A function to handle incoming messages, returning a string result.
     * @throws {Error} If the connection fails or the connector is invalid.
     */
    connect(connector: SendMessageFn$1, ...args: unknown[]): ReceiveMessageFn<string>;
    /**
     * Commits tool output to the session's history or state.
     * @param {string} toolId - The unique `tool_call_id` for tracking in OpenAI-style history.
     * @param {string} content - The output content from the tool.
     * @returns {Promise<void>} A promise that resolves when the output is committed.
     * @throws {Error} If the tool ID is invalid or committing fails.
     */
    commitToolOutput(toolId: string, content: string): Promise<void>;
    /**
     * Commits an assistant message to the session's history without triggering a response.
     * @param {string} message - The assistant message content to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     * @throws {Error} If committing the message fails.
     */
    commitAssistantMessage(message: string): Promise<void>;
    /**
     * Commits a user message to the session's history without triggering a response.
     * @param {string} message - The user message content to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     * @throws {Error} If committing the message fails.
     */
    commitUserMessage: (message: string) => Promise<void>;
    /**
     * Commits a flush operation to clear the session's agent history.
     * Resets the history to an initial state.
     * @returns {Promise<void>} A promise that resolves when the history is flushed.
     * @throws {Error} If flushing the history fails.
     */
    commitFlush: () => Promise<void>;
    /**
     * Prevents the next tool in the execution sequence from running.
     * Stops further tool calls within the session.
     * @returns {Promise<void>} A promise that resolves when the stop is committed.
     * @throws {Error} If stopping the tools fails.
     */
    commitStopTools: () => Promise<void>;
    /**
     * Commits a system message to the session's history or state.
     * @param {string} message - The system message content to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     * @throws {Error} If committing the message fails.
     */
    commitSystemMessage(message: string): Promise<void>;
}
/**
 * Type representing the unique identifier for a session.
 * @typedef {string} SessionId
 */
type SessionId = string;
/**
 * Type representing the operational mode of a session.
 * Defines the session's behavior: full session, connection setup, or single completion.
 * @typedef {"session" | "makeConnection" | "complete"} SessionMode
 */
type SessionMode = "session" | "makeConnection" | "complete";
/**
 * Type representing the source of execution within a session.
 * Tools emit "tool" messages (ignored in user history), while users emit "user" messages.
 * @typedef {"tool" | "user"} ExecutionMode
 */
type ExecutionMode = "tool" | "user";

/**
 * Interface representing a tool call request within the swarm system.
 * Encapsulates a specific invocation of a tool as requested by the model, used in agent workflows (e.g., ClientAgent) to bridge model outputs to executable actions.
 * Appears in IModelMessage.tool_calls (e.g., via ICompletion.getCompletion) and is processed by agents to execute tools, emit events (e.g., IBus.emit "commit-tool-output"), and update history (e.g., IHistory.push).
 */
interface IToolCall {
    /**
     * The unique identifier of the tool call.
     * Assigned to distinguish this invocation from others, often generated randomly (e.g., randomString() in ClientAgent.mapToolCalls) or provided by the model.
     * Used to correlate tool outputs back to their requests (e.g., tool_call_id in IModelMessage).
     * Example: "tool-xyz123" for a specific call in EXECUTE_FN.
     * @type {string}
     */
    id: string;
    /**
     * The type of the tool being called, currently fixed to "function".
     * Indicates that the tool is a callable function, aligning with the swarm’s function-based tool model (e.g., ClientAgent.createToolCall).
     * Future extensions might support other types, but "function" is the only supported value as observed.
     * @type {"function"}
     */
    type: "function";
    /**
     * The function details specifying the tool to be executed.
     * Defines the name and arguments of the function to invoke, derived from model outputs (e.g., ICompletion.getCompletion in ClientAgent).
     * Processed by agents to match against ITool definitions and execute via callbacks (e.g., targetFn.call).
     */
    function: {
        /**
         * The name of the function to be called.
         * Identifies the specific tool function (e.g., "search" or "calculate") requested by the model, matched against ITool.function.name in ClientAgent.
         * Example: "search" for a search tool invoked in EXECUTE_FN.
         * @type {string}
         */
        name: string;
        /**
         * The arguments to be passed to the function, as a key-value object.
         * Contains the parameters provided by the model for the tool call, validated and executed in ClientAgent (e.g., targetFn.validate, targetFn.call).
         * Example: `{ query: "example" }` for a search tool’s input.
         * @type {{ [key: string]: any }}
         */
        arguments: {
            [key: string]: any;
        };
    };
}
/**
 * Interface representing a tool definition within the swarm system.
 * Defines the metadata and schema for a callable tool, used by agents (e.g., ClientAgent) to provide the model with available functions and validate/execute tool calls.
 * Integrated into IAgentParams.tools and passed to ICompletion.getCompletion, enabling the model to generate IToolCall requests based on this specification.
 */
interface ITool {
    /**
     * The type of the tool, typically "function" in the current system.
     * Specifies the tool’s category, aligning with IToolCall.type, though only "function" is observed in ClientAgent usage (e.g., params.tools).
     * Future extensions might include other types (e.g., "api", "script"), but "function" is standard.
     * @type {string}
     */
    type: string;
    /**
     * The function details defining the tool’s capabilities.
     * Provides the name, description, and parameter schema for the tool, used by the model to understand and invoke it (e.g., in ClientAgent.getCompletion).
     * Matched against IToolCall.function during execution (e.g., EXECUTE_FN’s targetFn lookup).
     */
    function: {
        /**
         * The name of the function, uniquely identifying the tool.
         * Must match IToolCall.function.name for execution (e.g., "search" in ClientAgent.tools), serving as the key for tool lookup and invocation.
         * Example: "calculate" for a math tool.
         * @type {string}
         */
        name: string;
        /**
         * A human-readable description of the function’s purpose.
         * Informs the model or users about the tool’s functionality (e.g., "Performs a search query"), used in tool selection or documentation.
         * Not directly executed but critical for model understanding in ClientAgent workflows.
         * @type {string}
         */
        description: string;
        /**
         * The schema defining the parameters required by the function.
         * Specifies the structure, types, and constraints of arguments (e.g., IToolCall.function.arguments), validated in ClientAgent (e.g., targetFn.validate).
         * Provides the model with a blueprint for generating valid tool calls.
         */
        parameters: {
            /**
             * The type of the parameters object, typically "object".
             * Indicates that parameters are a key-value structure, as expected by IToolCall.function.arguments in ClientAgent.
             * Example: "object" for a standard JSON-like parameter set.
             * @type {string}
             */
            type: string;
            /**
             * An array of parameter names that are mandatory for the function.
             * Lists keys that must be present in IToolCall.function.arguments, enforced during validation (e.g., ClientAgent.targetFn.validate).
             * Example: ["query"] for a search tool requiring a query string.
             * @type {string[]}
             */
            required: string[];
            /**
             * A key-value map defining the properties of the parameters.
             * Details each argument’s type, description, and optional constraints, guiding the model and agent in constructing and validating tool calls (e.g., in ClientAgent.EXECUTE_FN).
             */
            properties: {
                [key: string]: {
                    /**
                     * The data type of the parameter property (e.g., "string", "number").
                     * Specifies the expected type for validation (e.g., ClientAgent.targetFn.validate), ensuring compatibility with IToolCall.function.arguments.
                     * Example: "string" for a query parameter.
                     * @type {string}
                     */
                    type: string;
                    /**
                     * A description of the parameter property’s purpose.
                     * Provides context for the model or users (e.g., "The search term to query"), not executed but used for tool comprehension.
                     * Example: "The value to search for" for a query parameter.
                     * @type {string}
                     */
                    description: string;
                    /**
                     * An optional array of allowed values for the parameter, if constrained.
                     * Defines an enumeration of valid options, checked during validation (e.g., ClientAgent.targetFn.validate) to restrict input.
                     * Example: ["asc", "desc"] for a sort direction parameter.
                     * @type {string[] | undefined}
                     */
                    enum?: string[];
                };
            };
        };
    };
}

/**
 * Interface representing a model message within the swarm system.
 * Encapsulates a single message exchanged between agents, tools, users, or the system, used extensively in agent workflows (e.g., ClientAgent) for history tracking, completion generation, and event emission.
 * Messages are stored in history (e.g., via IHistory.push), generated by completions (e.g., ICompletion.getCompletion), and emitted via the bus (e.g., IBus.emit), serving as the core data structure for communication and state management.
 */
interface IModelMessage {
    /**
     * The role of the message sender, defining its origin or purpose in the conversation flow.
     * Observed in ClientAgent usage:
     * - `"assistant"`: Generated by the model (e.g., getCompletion output, commitAssistantMessage).
     * - `"system"`: System-level notifications (e.g., commitSystemMessage).
     * - `"tool"`: Tool outputs or tool-related messages (e.g., commitToolOutput, resurrection prompts).
     * - `"user"`: User-initiated messages (e.g., commitUserMessage, EXECUTE_FN input).
     * - `"resque"`: Error recovery messages during model resurrection (e.g., _resurrectModel).
     * - `"flush"`: Markers for history resets (e.g., commitFlush).
     * @type {"assistant" | "system" | "tool" | "user" | "resque" | "flush"}
     */
    role: "assistant" | "system" | "tool" | "user" | "resque" | "flush";
    /**
     * The name of the agent associated with the message.
     * Links the message to a specific agent instance (e.g., this.params.agentName in ClientAgent), ensuring context within multi-agent swarms.
     * Used consistently in history pushes and bus events (e.g., context.agentName in IBus.emit).
     * @type {string}
     */
    agentName: string;
    /**
     * The content of the message, representing the primary data or text being communicated.
     * Examples from ClientAgent:
     * - User input (e.g., incoming in execute).
     * - Tool output (e.g., content in commitToolOutput).
     * - Model response (e.g., result from getCompletion).
     * - Error reasons or placeholders (e.g., _resurrectModel).
     * May be empty (e.g., "" in flush messages) or trimmed for consistency.
     * @type {string}
     */
    content: string;
    /**
     * The execution mode indicating the source or context of the message.
     * Aligns with ExecutionMode ("user" or "tool") from Session.interface:
     * - `"user"`: Messages from user input or stateless runs (e.g., commitUserMessage, RUN_FN).
     * - `"tool"`: Messages from tool outputs or system actions (e.g., commitToolOutput, _resurrectModel).
     * Drives processing logic, such as validation or tool call handling in ClientAgent.
     * @type {ExecutionMode}
     */
    mode: ExecutionMode;
    /**
     * Optional array of tool calls associated with the message, present when the model requests tool execution.
     * Populated in getCompletion responses (e.g., ClientAgent EXECUTE_FN), mapped to IToolCall objects for execution.
     * Example: `{ function: { name: "func", arguments: { key: "value" } }, id: "tool-id" }`.
     * Absent in user, system, or tool output messages unless explicitly triggered by the model.
     * @type {IToolCall[] | undefined}
     */
    tool_calls?: IToolCall[];
    /**
     * Optional identifier of the tool call this message responds to, linking tool outputs to their requests.
     * Set in tool-related messages (e.g., commitToolOutput in ClientAgent) to correlate with a prior tool_calls entry.
     * Example: `tool_call_id: "tool-id"` ties a tool’s output to its originating call.
     * Undefined for non-tool-response messages (e.g., user input, assistant responses without tools).
     * @type {string | undefined}
     */
    tool_call_id?: string;
}

/**
 * Identifier for an entity, can be a string or number.
 * @typedef {string | number} EntityId
 */
type EntityId = string | number;
/**
 * Base interface for all persistent entities.
 * @interface IEntity
 */
interface IEntity {
}
/** @private Symbol for memoizing the wait-for-initialization operation in PersistBase */
declare const BASE_WAIT_FOR_INIT_SYMBOL: unique symbol;
/** @private Symbol for creating a new key in a persistent list */
declare const LIST_CREATE_KEY_SYMBOL: unique symbol;
/** @private Symbol for getting the last key in a persistent list */
declare const LIST_GET_LAST_KEY_SYMBOL: unique symbol;
/** @private Symbol for popping the last item from a persistent list */
declare const LIST_POP_SYMBOL: unique symbol;
/**
 * Interface defining methods for persistent storage operations.
 * @template Entity - The type of entity, defaults to IEntity.
 */
interface IPersistBase<Entity extends IEntity = IEntity> {
    /**
     * Initializes the storage, creating directories and validating existing data.
     * @param {boolean} initial - Whether this is the initial setup (affects caching behavior).
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    waitForInit(initial: boolean): Promise<void>;
    /**
     * Reads an entity from storage by its ID.
     * @param {EntityId} entityId - The ID of the entity to read.
     * @returns {Promise<Entity>} A promise resolving to the entity.
     * @throws {Error} If the entity is not found or reading fails.
     */
    readValue(entityId: EntityId): Promise<Entity>;
    /**
     * Checks if an entity exists in storage.
     * @param {EntityId} entityId - The ID of the entity to check.
     * @returns {Promise<boolean>} A promise resolving to true if the entity exists, false otherwise.
     * @throws {Error} If checking existence fails (other than not found).
     */
    hasValue(entityId: EntityId): Promise<boolean>;
    /**
     * Writes an entity to storage with the specified ID.
     * @param {EntityId} entityId - The ID of the entity to write.
     * @param {Entity} entity - The entity data to write.
     * @returns {Promise<void>} A promise that resolves when writing is complete.
     * @throws {Error} If writing fails.
     */
    writeValue(entityId: EntityId, entity: Entity): Promise<void>;
}
/**
 * Constructor type for creating PersistBase instances.
 * @template EntityName - The type of entity name, defaults to string.
 * @template Entity - The type of entity, defaults to IEntity.
 * @typedef {new (entityName: EntityName, baseDir: string) => IPersistBase<Entity>} TPersistBaseCtor
 */
type TPersistBaseCtor<EntityName extends string = string, Entity extends IEntity = IEntity> = new (entityName: EntityName, baseDir: string) => IPersistBase<Entity>;
/**
 * Base class for persistent storage of entities in the file system.
 * @template EntityName - The type of entity name, defaults to string.
 * @implements {IPersistBase}
 */
declare class PersistBase<EntityName extends string = string> implements IPersistBase {
    readonly entityName: EntityName;
    readonly baseDir: string;
    /** @private The directory path where entity files are stored */
    _directory: string;
    /**
     * Creates a new PersistBase instance for managing persistent storage.
     * @param {EntityName} entityName - The name of the entity type (used as a subdirectory).
     * @param {string} [baseDir=join(process.cwd(), "logs/data")] - The base directory for storing entity files.
     */
    constructor(entityName: EntityName, baseDir?: string);
    /**
     * Computes the file path for an entity based on its ID.
     * @param {EntityId} entityId - The ID of the entity.
     * @returns {string} The full file path for the entity (e.g., `<baseDir>/<entityName>/<entityId>.json`).
     * @private
     */
    _getFilePath(entityId: EntityId): string;
    /**
     * Memoized initialization function to ensure it runs only once.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     * @private
     */
    private [BASE_WAIT_FOR_INIT_SYMBOL];
    /**
     * Initializes the storage directory and validates existing entities.
     * Creates the directory if it doesn't exist and removes invalid files.
     * @param {boolean} initial - Whether this is the initial setup (unused in this implementation).
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    waitForInit(initial: boolean): Promise<void>;
    /**
     * Retrieves the number of entities stored in the directory.
     * @returns {Promise<number>} A promise resolving to the count of `.json` files.
     * @throws {Error} If reading the directory fails.
     */
    getCount(): Promise<number>;
    /**
     * Reads an entity from storage by its ID.
     * @template T - The type of the entity, defaults to IEntity.
     * @param {EntityId} entityId - The ID of the entity to read.
     * @returns {Promise<T>} A promise resolving to the entity data.
     * @throws {Error} If the file is not found (`ENOENT`) or parsing fails.
     */
    readValue<T extends IEntity = IEntity>(entityId: EntityId): Promise<T>;
    /**
     * Checks if an entity exists in storage by its ID.
     * @param {EntityId} entityId - The ID of the entity to check.
     * @returns {Promise<boolean>} A promise resolving to true if the entity exists, false otherwise.
     * @throws {Error} If checking existence fails (other than not found).
     */
    hasValue(entityId: EntityId): Promise<boolean>;
    /**
     * Writes an entity to storage with the specified ID.
     * @template T - The type of the entity, defaults to IEntity.
     * @param {EntityId} entityId - The ID of the entity to write.
     * @param {T} entity - The entity data to write.
     * @returns {Promise<void>} A promise that resolves when writing is complete.
     * @throws {Error} If writing to the file fails.
     */
    writeValue<T extends IEntity = IEntity>(entityId: EntityId, entity: T): Promise<void>;
    /**
     * Removes an entity from storage by its ID.
     * @param {EntityId} entityId - The ID of the entity to remove.
     * @returns {Promise<void>} A promise that resolves when removal is complete.
     * @throws {Error} If the entity is not found or removal fails.
     */
    removeValue(entityId: EntityId): Promise<void>;
    /**
     * Removes all entities from storage.
     * @returns {Promise<void>} A promise that resolves when all entities are removed.
     * @throws {Error} If reading the directory or removing files fails.
     */
    removeAll(): Promise<void>;
    /**
     * Iterates over all entities in storage, sorted numerically by ID.
     * @template T - The type of the entities, defaults to IEntity.
     * @returns {AsyncGenerator<T>} An async generator yielding entities.
     * @throws {Error} If reading the directory or entity files fails.
     */
    values<T extends IEntity = IEntity>(): AsyncGenerator<T>;
    /**
     * Iterates over all entity IDs in storage, sorted numerically.
     * @returns {AsyncGenerator<EntityId>} An async generator yielding entity IDs.
     * @throws {Error} If reading the directory fails.
     */
    keys(): AsyncGenerator<EntityId>;
    /**
     * Implements the async iterator protocol for iterating over entities.
     * @returns {AsyncIterableIterator<any>} An async iterator yielding entities.
     */
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    /**
     * Filters entities based on a predicate function.
     * @template T - The type of the entities, defaults to IEntity.
     * @param {(value: T) => boolean} predicate - A function to test each entity.
     * @returns {AsyncGenerator<T>} An async generator yielding entities that pass the predicate.
     */
    filter<T extends IEntity = IEntity>(predicate: (value: T) => boolean): AsyncGenerator<T>;
    /**
     * Takes a limited number of entities, optionally filtered by a predicate.
     * @template T - The type of the entities, defaults to IEntity.
     * @param {number} total - The maximum number of entities to yield.
     * @param {(value: T) => boolean} [predicate] - Optional function to filter entities.
     * @returns {AsyncGenerator<T>} An async generator yielding up to `total` entities.
     */
    take<T extends IEntity = IEntity>(total: number, predicate?: (value: T) => boolean): AsyncGenerator<T>;
}
/**
 * Extends PersistBase to provide a persistent list structure with push/pop operations.
 * @template EntityName - The type of entity name, defaults to string.
 * @extends {PersistBase<EntityName>}
 */
declare class PersistList<EntityName extends string = string> extends PersistBase<EntityName> {
    /** @private Tracks the last used numeric key for the list, null until initialized */
    _lastCount: number | null;
    /**
     * Creates a new PersistList instance for managing a persistent list.
     * @param {EntityName} entityName - The name of the entity type (used as a subdirectory).
     * @param {string} [baseDir] - The base directory for storing list files (defaults to parent class).
     */
    constructor(entityName: EntityName, baseDir?: string);
    /**
     * Queued function to create a new unique key for a list item.
     * Ensures sequential key generation even under concurrent calls.
     * @returns {Promise<string>} A promise resolving to the new key as a string.
     * @private
     */
    private [LIST_CREATE_KEY_SYMBOL];
    /**
     * Retrieves the key of the last item in the list.
     * @returns {Promise<string | null>} A promise resolving to the last key or null if the list is empty.
     * @private
     */
    private [LIST_GET_LAST_KEY_SYMBOL];
    /**
     * Queued function to remove and return the last item in the list.
     * Ensures atomic pop operations under concurrent calls.
     * @template T - The type of the entity, defaults to IEntity.
     * @returns {Promise<T | null>} A promise resolving to the removed item or null if the list is empty.
     * @private
     */
    private [LIST_POP_SYMBOL];
    /**
     * Adds an entity to the end of the persistent list with a new unique key.
     * @template T - The type of the entity, defaults to IEntity.
     * @param {T} entity - The entity to add to the list.
     * @returns {Promise<void>} A promise that resolves when the entity is written.
     * @throws {Error} If writing to the file fails.
     */
    push<T extends IEntity = IEntity>(entity: T): Promise<void>;
    /**
     * Removes and returns the last entity from the persistent list.
     * @template T - The type of the entity, defaults to IEntity.
     * @returns {Promise<T | null>} A promise resolving to the removed entity or null if the list is empty.
     * @throws {Error} If reading or removing the entity fails.
     */
    pop<T extends IEntity = IEntity>(): Promise<T | null>;
}
/**
 * Interface for data stored in active agent persistence.
 */
interface IPersistActiveAgentData {
    /** The name of the active agent */
    agentName: AgentName;
}
/**
 * Interface for data stored in navigation stack persistence.
 */
interface IPersistNavigationStackData {
    /** The stack of agent names representing navigation history */
    agentStack: AgentName[];
}
/**
 * Interface defining control methods for swarm persistence operations.
 */
interface IPersistSwarmControl {
    /**
     * Sets a custom persistence adapter for active agent storage.
     * @param {TPersistBaseCtor<SwarmName, IPersistActiveAgentData>} Ctor - The constructor for active agent persistence.
     */
    usePersistActiveAgentAdapter(Ctor: TPersistBaseCtor<SwarmName, IPersistActiveAgentData>): void;
    /**
     * Sets a custom persistence adapter for navigation stack storage.
     * @param {TPersistBaseCtor<SwarmName, IPersistNavigationStackData>} Ctor - The constructor for navigation stack persistence.
     */
    usePersistNavigationStackAdapter(Ctor: TPersistBaseCtor<SwarmName, IPersistNavigationStackData>): void;
}
/**
 * Utility class for managing swarm-related persistence (active agents and navigation stacks).
 * @implements {IPersistSwarmControl}
 */
declare class PersistSwarmUtils implements IPersistSwarmControl {
    /** @private Default constructor for active agent persistence, defaults to PersistBase */
    private PersistActiveAgentFactory;
    /** @private Default constructor for navigation stack persistence, defaults to PersistBase */
    private PersistNavigationStackFactory;
    /**
     * Memoized function to create or retrieve storage for active agents.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {IPersistBase<IPersistActiveAgentData>} A persistence instance for active agents.
     * @private
     */
    private getActiveAgentStorage;
    /**
     * Sets a custom constructor for active agent persistence.
     * @param {TPersistBaseCtor<SwarmName, IPersistActiveAgentData>} Ctor - The constructor to use.
     */
    usePersistActiveAgentAdapter(Ctor: TPersistBaseCtor<SwarmName, IPersistActiveAgentData>): void;
    /**
     * Sets a custom constructor for navigation stack persistence.
     * @param {TPersistBaseCtor<SwarmName, IPersistNavigationStackData>} Ctor - The constructor to use.
     */
    usePersistNavigationStackAdapter(Ctor: TPersistBaseCtor<SwarmName, IPersistNavigationStackData>): void;
    /**
     * Memoized function to create or retrieve storage for navigation stacks.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {IPersistBase<IPersistNavigationStackData>} A persistence instance for navigation stacks.
     * @private
     */
    private getNavigationStackStorage;
    /**
     * Retrieves the active agent for a client in a swarm.
     * @param {string} clientId - The client identifier.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {AgentName} defaultAgent - The default agent name to return if none is set.
     * @returns {Promise<AgentName>} A promise resolving to the active agent name.
     * @throws {Error} If reading from storage fails.
     */
    getActiveAgent: (clientId: string, swarmName: SwarmName, defaultAgent: AgentName) => Promise<AgentName>;
    /**
     * Sets the active agent for a client in a swarm.
     * @param {string} clientId - The client identifier.
     * @param {AgentName} agentName - The name of the agent to set as active.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {Promise<void>} A promise that resolves when the active agent is written.
     * @throws {Error} If writing to storage fails.
     */
    setActiveAgent: (clientId: string, agentName: AgentName, swarmName: SwarmName) => Promise<void>;
    /**
     * Retrieves the navigation stack for a client in a swarm.
     * @param {string} clientId - The client identifier.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {Promise<AgentName[]>} A promise resolving to the navigation stack (array of agent names).
     * @throws {Error} If reading from storage fails.
     */
    getNavigationStack: (clientId: string, swarmName: SwarmName) => Promise<AgentName[]>;
    /**
     * Sets the navigation stack for a client in a swarm.
     * @param {string} clientId - The client identifier.
     * @param {AgentName[]} agentStack - The navigation stack (array of agent names) to set.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {Promise<void>} A promise that resolves when the navigation stack is written.
     * @throws {Error} If writing to storage fails.
     */
    setNavigationStack: (clientId: string, agentStack: AgentName[], swarmName: SwarmName) => Promise<void>;
}
/**
 * Exported singleton for swarm persistence operations, cast as the control interface.
 * @type {IPersistSwarmControl}
 */
declare const PersistSwarm: IPersistSwarmControl;
/**
 * Interface for state data persistence.
 * @template T - The type of the state data, defaults to unknown.
 */
interface IPersistStateData<T = unknown> {
    /** The state data to persist */
    state: T;
}
/**
 * Interface defining control methods for state persistence operations.
 */
interface IPersistStateControl {
    /**
     * Sets a custom persistence adapter for state storage.
     * @param {TPersistBaseCtor<StorageName, IPersistStateData>} Ctor - The constructor for state persistence.
     */
    usePersistStateAdapter(Ctor: TPersistBaseCtor<StorageName, IPersistStateData>): void;
}
/**
 * Utility class for managing state persistence.
 * @implements {IPersistStateControl}
 */
declare class PersistStateUtils implements IPersistStateControl {
    /** @private Default constructor for state persistence, defaults to PersistBase */
    private PersistStateFactory;
    /**
     * Memoized function to create or retrieve storage for a specific state.
     * @param {StateName} stateName - The name of the state.
     * @returns {IPersistBase<IPersistStateData>} A persistence instance for the state.
     * @private
     */
    private getStateStorage;
    /**
     * Sets a custom constructor for state persistence.
     * @param {TPersistBaseCtor<StorageName, IPersistStateData>} Ctor - The constructor to use.
     */
    usePersistStateAdapter(Ctor: TPersistBaseCtor<StorageName, IPersistStateData>): void;
    /**
     * Sets the state for a client under a specific state name.
     * @template T - The type of the state data, defaults to unknown.
     * @param {T} state - The state data to persist.
     * @param {string} clientId - The client identifier.
     * @param {StateName} stateName - The name of the state.
     * @returns {Promise<void>} A promise that resolves when the state is written.
     * @throws {Error} If writing to storage fails.
     */
    setState: <T = unknown>(state: T, clientId: string, stateName: StateName) => Promise<void>;
    /**
     * Retrieves the state for a client under a specific state name.
     * @template T - The type of the state data, defaults to unknown.
     * @param {string} clientId - The client identifier.
     * @param {StateName} stateName - The name of the state.
     * @param {T} defaultState - The default state to return if none is set.
     * @returns {Promise<T>} A promise resolving to the state data.
     * @throws {Error} If reading from storage fails.
     */
    getState: <T = unknown>(clientId: string, stateName: StateName, defaultState: T) => Promise<T>;
}
/**
 * Exported singleton for state persistence operations, cast as the control interface.
 * @type {IPersistStateControl}
 */
declare const PersistState: IPersistStateControl;
/**
 * Interface for storage data persistence.
 * @template T - The type of storage data, defaults to IStorageData.
 */
interface IPersistStorageData<T extends IStorageData = IStorageData> {
    /** The array of storage data to persist */
    data: T[];
}
/**
 * Interface defining control methods for storage persistence operations.
 */
interface IPersistStorageControl {
    /**
     * Sets a custom persistence adapter for storage.
     * @param {TPersistBaseCtor<StorageName, IPersistStorageData>} Ctor - The constructor for storage persistence.
     */
    usePersistStorageAdapter(Ctor: TPersistBaseCtor<StorageName, IPersistStorageData>): void;
}
/**
 * Utility class for managing storage persistence.
 * @implements {IPersistStorageControl}
 */
declare class PersistStorageUtils implements IPersistStorageControl {
    /** @private Default constructor for storage persistence, defaults to PersistBase */
    private PersistStorageFactory;
    /**
     * Memoized function to create or retrieve storage for a specific storage name.
     * @param {StorageName} storageName - The name of the storage.
     * @returns {IPersistBase<IPersistStorageData>} A persistence instance for the storage.
     * @private
     */
    private getPersistStorage;
    /**
     * Sets a custom constructor for storage persistence.
     * @param {TPersistBaseCtor<StorageName, IPersistStorageData>} Ctor - The constructor to use.
     */
    usePersistStorageAdapter(Ctor: TPersistBaseCtor<StorageName, IPersistStorageData>): void;
    /**
     * Retrieves the data for a client from a specific storage.
     * @template T - The type of the storage data, defaults to IStorageData.
     * @param {string} clientId - The client identifier.
     * @param {StorageName} storageName - The name of the storage.
     * @param {T[]} defaultValue - The default value to return if no data is set.
     * @returns {Promise<T[]>} A promise resolving to the storage data array.
     * @throws {Error} If reading from storage fails.
     */
    getData: <T extends IStorageData = IStorageData>(clientId: string, storageName: StorageName, defaultValue: T[]) => Promise<T[]>;
    /**
     * Sets the data for a client in a specific storage.
     * @template T - The type of the storage data, defaults to IStorageData.
     * @param {T[]} data - The array of data to persist.
     * @param {string} clientId - The client identifier.
     * @param {StorageName} storageName - The name of the storage.
     * @returns {Promise<void>} A promise that resolves when the data is written.
     * @throws {Error} If writing to storage fails.
     */
    setData: <T extends IStorageData = IStorageData>(data: T[], clientId: string, storageName: StorageName) => Promise<void>;
}
/**
 * Exported singleton for storage persistence operations, cast as the control interface.
 * @type {IPersistStorageControl}
 */
declare const PersistStorage: IPersistStorageControl;

/**
 * Callbacks for managing history instance lifecycle and message handling.
 */
interface IHistoryInstanceCallbacks {
    /**
     * Retrieves dynamic system prompt messages for an agent.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<string[]> | string[]} An array of system prompt message contents.
     */
    getSystemPrompt?: (clientId: string, agentName: AgentName) => Promise<string[]> | string[];
    /**
     * Determines whether a message should be included in the history iteration.
     * @param {IModelMessage} message - The message to evaluate.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<boolean> | boolean} Whether the message passes the filter.
     */
    filterCondition?: (message: IModelMessage, clientId: string, agentName: AgentName) => Promise<boolean> | boolean;
    /**
     * Fetches initial history data for an agent.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<IModelMessage[]> | IModelMessage[]} The initial array of history messages.
     */
    getData: (clientId: string, agentName: AgentName) => Promise<IModelMessage[]> | IModelMessage[];
    /**
     * Called when the history array changes (e.g., after push or pop).
     * @param {IModelMessage[]} data - The updated array of history messages.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     */
    onChange: (data: IModelMessage[], clientId: string, agentName: AgentName) => void;
    /**
     * Called when a new message is pushed to the history.
     * @param {IModelMessage} data - The newly pushed message.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     */
    onPush: (data: IModelMessage, clientId: string, agentName: AgentName) => void;
    /**
     * Called when the last message is popped from the history.
     * @param {IModelMessage | null} data - The popped message, or null if the history is empty.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     */
    onPop: (data: IModelMessage | null, clientId: string, agentName: AgentName) => void;
    /**
     * Called for each message during iteration when reading.
     * @param {IModelMessage} message - The current message being read.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     */
    onRead: (message: IModelMessage, clientId: string, agentName: AgentName) => void;
    /**
     * Called at the start of a history read operation.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     */
    onReadBegin: (clientId: string, agentName: AgentName) => void;
    /**
     * Called at the end of a history read operation.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     */
    onReadEnd: (clientId: string, agentName: AgentName) => void;
    /**
     * Called when the history instance is disposed.
     * @param {string} clientId - The client ID.
     */
    onDispose: (clientId: string) => void;
    /**
     * Called when the history instance is initialized.
     * @param {string} clientId - The client ID.
     */
    onInit: (clientId: string) => void;
    /**
     * Provides a reference to the history instance after creation.
     * @param {IHistoryInstance} history - The history instance.
     */
    onRef: (history: IHistoryInstance) => void;
}
/**
 * Interface defining methods for interacting with a history adapter.
 */
interface IHistoryAdapter {
    /**
     * Iterates over history messages for a client and agent.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {AsyncIterableIterator<IModelMessage>} An async iterator yielding history messages.
     */
    iterate(clientId: string, agentName: AgentName): AsyncIterableIterator<IModelMessage>;
    /**
     * Adds a new message to the history.
     * @param {IModelMessage} value - The message to add.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<void>} A promise that resolves when the message is added.
     */
    push: (value: IModelMessage, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Removes and returns the last message from the history.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<IModelMessage | null>} The last message, or null if the history is empty.
     */
    pop: (clientId: string, agentName: AgentName) => Promise<IModelMessage | null>;
    /**
     * Disposes of the history for a client and agent, optionally clearing all data.
     * @param {string} clientId - The client ID.
     * @param {AgentName | null} agentName - The name of the agent, or null to dispose fully.
     * @returns {Promise<void>} A promise that resolves when disposal is complete.
     */
    dispose: (clientId: string, agentName: AgentName | null) => Promise<void>;
}
/**
 * Interface defining control methods for configuring history behavior.
 */
interface IHistoryControl {
    /**
     * Sets a custom history instance constructor for the adapter.
     * @param {THistoryInstanceCtor} Ctor - The constructor for creating history instances.
     */
    useHistoryAdapter(Ctor: THistoryInstanceCtor): void;
    /**
     * Configures lifecycle callbacks for history instances.
     * @param {Partial<IHistoryInstanceCallbacks>} Callbacks - The callbacks to apply.
     */
    useHistoryCallbacks: (Callbacks: Partial<IHistoryInstanceCallbacks>) => void;
}
/**
 * Interface defining methods for a history instance implementation.
 */
interface IHistoryInstance {
    /**
     * Iterates over history messages for an agent.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {AsyncIterableIterator<IModelMessage>} An async iterator yielding history messages.
     */
    iterate(agentName: AgentName): AsyncIterableIterator<IModelMessage>;
    /**
     * Initializes the history for an agent, loading initial data if needed.
     * @param {AgentName} agentName - The name of the agent.
     * @param {boolean} init - Whether this is the initial setup (affects caching behavior).
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    waitForInit(agentName: AgentName, init: boolean): Promise<void>;
    /**
     * Adds a new message to the history for an agent.
     * @param {IModelMessage} value - The message to add.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<void>} A promise that resolves when the message is added.
     */
    push(value: IModelMessage, agentName: AgentName): Promise<void>;
    /**
     * Removes and returns the last message from the history for an agent.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<IModelMessage | null>} The last message, or null if the history is empty.
     */
    pop(agentName: AgentName): Promise<IModelMessage | null>;
    /**
     * Disposes of the history for an agent, optionally clearing all data.
     * @param {AgentName | null} agentName - The name of the agent, or null to dispose fully.
     * @returns {Promise<void>} A promise that resolves when disposal is complete.
     */
    dispose(agentName: AgentName | null): Promise<void>;
}
/**
 * Constructor type for creating history instances.
 * @typedef {new (clientId: string, callbacks: Partial<IHistoryInstanceCallbacks>) => IHistoryInstance} THistoryInstanceCtor
 */
type THistoryInstanceCtor = new (clientId: string, callbacks: Partial<IHistoryInstanceCallbacks>) => IHistoryInstance;
/** @private Symbol for memoizing the waitForInit method in HistoryMemoryInstance */
declare const HISTORY_MEMORY_INSTANCE_WAIT_FOR_INIT: unique symbol;
/** @private Symbol for memoizing the waitForInit method in HistoryPersistInstance */
declare const HISTORY_PERSIST_INSTANCE_WAIT_FOR_INIT: unique symbol;
/**
 * Manages a persistent history of messages, storing them in memory and on disk.
 * @implements {IHistoryInstance}
 */
declare class HistoryPersistInstance implements IHistoryInstance {
    readonly clientId: string;
    readonly callbacks: Partial<IHistoryInstanceCallbacks>;
    /** @private The in-memory array of history messages */
    _array: IModelMessage[];
    /** @private The persistent storage instance for history messages */
    _persistStorage: PersistList;
    /**
     * Memoized initialization function to ensure it runs only once per agent.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     * @private
     */
    private [HISTORY_PERSIST_INSTANCE_WAIT_FOR_INIT];
    /**
     * Initializes the history for an agent, loading data from persistent storage if needed.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    waitForInit(agentName: AgentName): Promise<void>;
    /**
     * Creates a new persistent history instance.
     * Invokes onInit and onRef callbacks if provided.
     * @param {string} clientId - The client ID.
     * @param {Partial<IHistoryInstanceCallbacks>} callbacks - The lifecycle callbacks.
     */
    constructor(clientId: string, callbacks: Partial<IHistoryInstanceCallbacks>);
    /**
     * Iterates over history messages, applying filters and system prompts if configured.
     * Invokes onRead callbacks during iteration if provided.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {AsyncIterableIterator<IModelMessage>} An async iterator yielding filtered messages.
     */
    iterate(agentName: AgentName): AsyncIterableIterator<IModelMessage>;
    /**
     * Adds a new message to the history, persisting it to storage.
     * Invokes onPush and onChange callbacks if provided.
     * @param {IModelMessage} value - The message to add.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<void>} A promise that resolves when the message is persisted.
     */
    push(value: IModelMessage, agentName: AgentName): Promise<void>;
    /**
     * Removes and returns the last message from the history, updating persistent storage.
     * Invokes onPop and onChange callbacks if provided.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<IModelMessage | null>} The last message, or null if the history is empty.
     */
    pop(agentName: AgentName): Promise<IModelMessage | null>;
    /**
     * Disposes of the history, clearing all data if agentName is null.
     * Invokes onDispose callback if provided.
     * @param {AgentName | null} agentName - The name of the agent, or null to clear all data.
     * @returns {Promise<void>} A promise that resolves when disposal is complete.
     */
    dispose(agentName: AgentName | null): Promise<void>;
}
/**
 * Manages an in-memory history of messages without persistence.
 * @implements {IHistoryInstance}
 */
declare class HistoryMemoryInstance implements IHistoryInstance {
    readonly clientId: string;
    readonly callbacks: Partial<IHistoryInstanceCallbacks>;
    /** @private The in-memory array of history messages */
    _array: IModelMessage[];
    /**
     * Memoized initialization function to ensure it runs only once per agent.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     * @private
     */
    private [HISTORY_MEMORY_INSTANCE_WAIT_FOR_INIT];
    /**
     * Initializes the history for an agent, loading initial data if needed.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    waitForInit(agentName: AgentName): Promise<void>;
    /**
     * Creates a new in-memory history instance.
     * Invokes onInit and onRef callbacks if provided.
     * @param {string} clientId - The client ID.
     * @param {Partial<IHistoryInstanceCallbacks>} callbacks - The lifecycle callbacks.
     */
    constructor(clientId: string, callbacks: Partial<IHistoryInstanceCallbacks>);
    /**
     * Iterates over history messages, applying filters and system prompts if configured.
     * Invokes onRead callbacks during iteration if provided.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {AsyncIterableIterator<IModelMessage>} An async iterator yielding filtered messages.
     */
    iterate(agentName: AgentName): AsyncIterableIterator<IModelMessage>;
    /**
     * Adds a new message to the in-memory history.
     * Invokes onPush and onChange callbacks if provided.
     * @param {IModelMessage} value - The message to add.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<void>} A promise that resolves when the message is added.
     */
    push(value: IModelMessage, agentName: AgentName): Promise<void>;
    /**
     * Removes and returns the last message from the in-memory history.
     * Invokes onPop and onChange callbacks if provided.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<IModelMessage | null>} The last message, or null if the history is empty.
     */
    pop(agentName: AgentName): Promise<IModelMessage | null>;
    /**
     * Disposes of the history, clearing all data if agentName is null.
     * Invokes onDispose callback if provided.
     * @param {AgentName | null} agentName - The name of the agent, or null to clear all data.
     * @returns {Promise<void>} A promise that resolves when disposal is complete.
     */
    dispose(agentName: AgentName | null): Promise<void>;
}
/**
 * Exported History Control interface for configuring history behavior.
 * @type {IHistoryControl}
 */
declare const History: IHistoryControl;

/**
 * Interface representing the history of model messages within the swarm.
 * Provides methods to manage and retrieve a sequence of messages for an agent or raw usage.
 */
interface IHistory {
    /**
     * Adds a message to the end of the history.
     * Updates the history store asynchronously.
     * @param {IModelMessage} message - The model message to append to the history.
     * @returns {Promise<void>} A promise that resolves when the message is successfully added.
     * @throws {Error} If the push operation fails (e.g., due to storage issues or invalid message).
     */
    push(message: IModelMessage): Promise<void>;
    /**
     * Removes and returns the last message from the history.
     * @returns {Promise<IModelMessage | null>} A promise resolving to the last message if available, or null if the history is empty.
     * @throws {Error} If the pop operation fails (e.g., due to internal errors).
     */
    pop(): Promise<IModelMessage | null>;
    /**
     * Converts the history into an array of messages tailored for a specific agent.
     * Filters or formats messages based on the provided prompt and optional system prompts.
     * @param {string} prompt - The prompt used to contextualize or filter messages for the agent.
     * @param {string[]} [system] - Optional array of system prompts to include or influence message formatting.
     * @returns {Promise<IModelMessage[]>} A promise resolving to an array of model messages formatted for the agent.
     * @throws {Error} If conversion fails (e.g., due to adapter issues or invalid prompt).
     */
    toArrayForAgent(prompt: string, system?: string[]): Promise<IModelMessage[]>;
    /**
     * Converts the entire history into an array of raw model messages.
     * Retrieves all messages without agent-specific filtering or formatting.
     * @returns {Promise<IModelMessage[]>} A promise resolving to an array of raw model messages.
     * @throws {Error} If conversion fails (e.g., due to adapter issues).
     */
    toArrayForRaw(): Promise<IModelMessage[]>;
}
/**
 * Interface representing the parameters required to create a history instance.
 * Extends the history schema with runtime dependencies for agent-specific history management.
 * @extends {IHistorySchema}
 */
interface IHistoryParams extends IHistorySchema {
    /** The unique name of the agent associated with this history instance. */
    agentName: AgentName;
    /** The unique ID of the client associated with this history instance. */
    clientId: string;
    /** The logger instance for recording history-related activity and errors. */
    logger: ILogger;
    /** The bus instance for event communication within the swarm. */
    bus: IBus;
}
/**
 * Interface representing the schema for history configuration.
 * Defines the underlying storage mechanism for model messages.
 */
interface IHistorySchema {
    /**
     * The adapter responsible for managing the array of model messages.
     * Provides the implementation for history storage and retrieval.
     */
    items: IHistoryAdapter;
}

/**
 * Interface representing a completion mechanism.
 * Extends the completion schema to provide a complete API for generating model responses.
 * @extends {ICompletionSchema}
 */
interface ICompletion extends ICompletionSchema {
}
/**
 * Interface representing the arguments required to request a completion.
 * Encapsulates context and inputs for generating a model response.
 */
interface ICompletionArgs {
    /** The unique ID of the client requesting the completion. */
    clientId: string;
    /** The unique name of the agent associated with the completion request. */
    agentName: AgentName;
    /** The source of the last message, indicating whether it originated from a tool or user. */
    mode: ExecutionMode;
    /** An array of model messages providing the conversation history or context for the completion. */
    messages: IModelMessage[];
    /** Optional array of tools available for the completion process (e.g., for tool calls). */
    tools?: ITool[];
}
/**
 * Interface representing lifecycle callbacks for completion events.
 * Provides hooks for post-completion actions.
 */
interface ICompletionCallbacks {
    /**
     * Optional callback triggered after a completion is successfully generated.
     * Useful for logging, output processing, or triggering side effects.
     * @param {ICompletionArgs} args - The arguments used to generate the completion.
     * @param {IModelMessage} output - The model-generated message resulting from the completion.
     */
    onComplete?: (args: ICompletionArgs, output: IModelMessage) => void;
}
/**
 * Interface representing the schema for configuring a completion mechanism.
 * Defines how completions are generated within the swarm.
 */
interface ICompletionSchema {
    /** The unique name of the completion mechanism within the swarm. */
    completionName: CompletionName;
    /**
     * Retrieves a completion based on the provided arguments.
     * Generates a model response using the given context and tools.
     * @param {ICompletionArgs} args - The arguments required to generate the completion, including client, agent, and message context.
     * @returns {Promise<IModelMessage>} A promise resolving to the generated model message.
     * @throws {Error} If completion generation fails (e.g., due to invalid arguments, model errors, or tool issues).
     */
    getCompletion(args: ICompletionArgs): Promise<IModelMessage>;
    /** Optional partial set of callbacks for completion events, allowing customization of post-completion behavior. */
    callbacks?: Partial<ICompletionCallbacks>;
}
/**
 * Type representing the unique name of a completion mechanism within the swarm.
 * @typedef {string} CompletionName
 */
type CompletionName = string;

/**
 * Type representing possible values for tool parameters.
 * @typedef {string | number | boolean | null} ToolValue
 */
type ToolValue = string | number | boolean | null;
/**
 * Interface representing lifecycle callbacks for an agent tool.
 * Provides hooks for pre- and post-execution, validation, and error handling.
 * @template T - The type of the parameters for the tool, defaults to a record of ToolValue.
 */
interface IAgentToolCallbacks<T = Record<string, ToolValue>> {
    /**
     * Optional callback triggered before the tool is executed.
     * Useful for logging, pre-processing, or setup tasks.
     * @param {string} toolId - The unique `tool_call_id` for tracking in OpenAI-style history.
     * @param {string} clientId - The ID of the client invoking the tool.
     * @param {AgentName} agentName - The name of the agent using the tool.
     * @param {T} params - The parameters passed to the tool.
     * @returns {Promise<void>} A promise that resolves when pre-call actions are complete.
     */
    onBeforeCall?: (toolId: string, clientId: string, agentName: AgentName, params: T) => Promise<void>;
    /**
     * Optional callback triggered after the tool is executed.
     * Useful for cleanup, logging, or post-processing.
     * @param {string} toolId - The unique `tool_call_id` for tracking in OpenAI-style history.
     * @param {string} clientId - The ID of the client invoking the tool.
     * @param {AgentName} agentName - The name of the agent using the tool.
     * @param {T} params - The parameters passed to the tool.
     * @returns {Promise<void>} A promise that resolves when post-call actions are complete.
     */
    onAfterCall?: (toolId: string, clientId: string, agentName: AgentName, params: T) => Promise<void>;
    /**
     * Optional callback triggered to validate tool parameters before execution.
     * Allows custom validation logic specific to the tool.
     * @param {string} clientId - The ID of the client invoking the tool.
     * @param {AgentName} agentName - The name of the agent using the tool.
     * @param {T} params - The parameters to validate.
     * @returns {Promise<boolean>} A promise resolving to true if parameters are valid, false otherwise.
     */
    onValidate?: (clientId: string, agentName: AgentName, params: T) => Promise<boolean>;
    /**
     * Optional callback triggered when the tool execution fails.
     * Useful for error logging or recovery actions.
     * @param {string} toolId - The unique `tool_call_id` for tracking in OpenAI-style history.
     * @param {string} clientId - The ID of the client invoking the tool.
     * @param {AgentName} agentName - The name of the agent using the tool.
     * @param {T} params - The parameters passed to the tool.
     * @param {Error} error - The error that caused the failure.
     * @returns {Promise<void>} A promise that resolves when error handling is complete.
     */
    onCallError?: (toolId: string, clientId: string, agentName: AgentName, params: T, error: Error) => Promise<void>;
}
/**
 * Interface representing a tool used by an agent, extending the base ITool interface.
 * Defines the tool's execution and validation logic, with optional lifecycle callbacks.
 * @template T - The type of the parameters for the tool, defaults to a record of ToolValue.
 * @extends {ITool}
 */
interface IAgentTool<T = Record<string, ToolValue>> extends ITool {
    /** Optional description for documentation purposes, aiding in tool usage understanding. */
    docNote?: string;
    /** The unique name of the tool, used for identification within the agent swarm. */
    toolName: ToolName;
    /**
     * Executes the tool with the specified parameters and context.
     * @param {Object} dto - The data transfer object containing execution details.
     * @param {string} dto.toolId - The unique `tool_call_id` for tracking in OpenAI-style history.
     * @param {string} dto.clientId - The ID of the client invoking the tool.
     * @param {AgentName} dto.agentName - The name of the agent using the tool.
     * @param {T} dto.params - The parameters for the tool execution.
     * @param {IToolCall[]} dto.toolCalls - The list of tool calls in the current execution context.
     * @param {boolean} dto.isLast - Indicates if this is the last tool call in a sequence.
     * @returns {Promise<void>} A promise that resolves when the tool execution is complete.
     * @throws {Error} If the tool execution fails or parameters are invalid.
     */
    call(dto: {
        toolId: string;
        clientId: string;
        agentName: AgentName;
        params: T;
        toolCalls: IToolCall[];
        isLast: boolean;
    }): Promise<void>;
    /**
     * Validates the tool parameters before execution.
     * Can return synchronously or asynchronously based on validation complexity.
     * @param {Object} dto - The data transfer object containing validation details.
     * @param {string} dto.clientId - The ID of the client invoking the tool.
     * @param {AgentName} dto.agentName - The name of the agent using the tool.
     * @param {IToolCall[]} dto.toolCalls - The list of tool calls in the current execution context.
     * @param {T} dto.params - The parameters to validate.
     * @returns {Promise<boolean> | boolean} True if parameters are valid, false otherwise.
     */
    validate(dto: {
        clientId: string;
        agentName: AgentName;
        toolCalls: IToolCall[];
        params: T;
    }): Promise<boolean> | boolean;
    /** Optional lifecycle callbacks for the tool, allowing customization of execution flow. */
    callbacks?: Partial<IAgentToolCallbacks>;
}
/**
 * Interface representing the runtime parameters for an agent.
 * Combines schema properties (excluding certain fields) with callbacks and runtime dependencies.
 * @extends {Omit<IAgentSchema, "tools" | "completion" | "validate">}
 * @extends {IAgentSchemaCallbacks}
 */
interface IAgentParams extends Omit<IAgentSchema, keyof {
    tools: never;
    completion: never;
    validate: never;
}>, IAgentSchemaCallbacks {
    /** The ID of the client interacting with the agent. */
    clientId: string;
    /** The logger instance for recording agent activity and errors. */
    logger: ILogger;
    /** The bus instance for event communication within the swarm. */
    bus: IBus;
    /** The history instance for tracking agent interactions. */
    history: IHistory;
    /** The completion instance for generating responses or outputs. */
    completion: ICompletion;
    /** Optional array of tools available to the agent for execution. */
    tools?: IAgentTool[];
    /**
     * Validates the agent's output before finalization.
     * @param {string} output - The output string to validate.
     * @returns {Promise<string | null>} A promise resolving to the validated output or null if invalid.
     */
    validate: (output: string) => Promise<string | null>;
}
/**
 * Interface representing lifecycle callbacks for an agent.
 * Provides hooks for various stages of agent execution and interaction.
 */
interface IAgentSchemaCallbacks {
    /**
     * Optional callback triggered when the agent runs statelessly (without history updates).
     * @param {string} clientId - The ID of the client invoking the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @param {string} input - The input provided to the agent.
     */
    onRun?: (clientId: string, agentName: AgentName, input: string) => void;
    /**
     * Optional callback triggered when the agent begins execution.
     * @param {string} clientId - The ID of the client invoking the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @param {string} input - The input provided to the agent.
     * @param {ExecutionMode} mode - The execution source (e.g., "tool" or "user").
     */
    onExecute?: (clientId: string, agentName: AgentName, input: string, mode: ExecutionMode) => void;
    /**
     * Optional callback triggered when a tool produces output.
     * @param {string} toolId - The unique `tool_call_id` for tracking in OpenAI-style history.
     * @param {string} clientId - The ID of the client invoking the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @param {string} content - The output content from the tool.
     */
    onToolOutput?: (toolId: string, clientId: string, agentName: AgentName, content: string) => void;
    /**
     * Optional callback triggered when a system message is generated.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @param {string} message - The system message content.
     */
    onSystemMessage?: (clientId: string, agentName: AgentName, message: string) => void;
    /**
     * Optional callback triggered when an assistant message is committed.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @param {string} message - The assistant message content.
     */
    onAssistantMessage?: (clientId: string, agentName: AgentName, message: string) => void;
    /**
     * Optional callback triggered when a user message is received.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @param {string} message - The user message content.
     */
    onUserMessage?: (clientId: string, agentName: AgentName, message: string) => void;
    /**
     * Optional callback triggered when the agent's history is flushed.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     */
    onFlush?: (clientId: string, agentName: AgentName) => void;
    /**
     * Optional callback triggered when the agent produces output.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     * W
     * @param {string} output - The output string generated by the agent.
     */
    onOutput?: (clientId: string, agentName: AgentName, output: string) => void;
    /**
     * Optional callback triggered when the agent is resurrected after a pause or failure.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @param {ExecutionMode} mode - The execution source (e.g., "tool" or "user").
     * @param {string} [reason] - Optional reason for the resurrection.
     */
    onResurrect?: (clientId: string, agentName: AgentName, mode: ExecutionMode, reason?: string) => void;
    /**
     * Optional callback triggered when the agent is initialized.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     */
    onInit?: (clientId: string, agentName: AgentName) => void;
    /**
     * Optional callback triggered when the agent is disposed of.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     */
    onDispose?: (clientId: string, agentName: AgentName) => void;
    /**
     * Optional callback triggered after all tool calls in a sequence are completed.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @param {IToolCall[]} toolCalls - The array of tool calls executed.
     */
    onAfterToolCalls?: (clientId: string, agentName: AgentName, toolCalls: IToolCall[]) => void;
}
/**
 * Interface representing the configuration schema for an agent.
 * Defines the agent's properties, tools, and lifecycle behavior.
 */
interface IAgentSchema {
    /**
     * Optional function to filter or modify tool calls before execution.
     * @param {IToolCall[]} tool - The array of tool calls to process.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {IToolCall[] | Promise<IToolCall[]>} The filtered or modified tool calls.
     */
    mapToolCalls?: (tool: IToolCall[], clientId: string, agentName: AgentName) => IToolCall[] | Promise<IToolCall[]>;
    /** Optional maximum number of tool calls allowed per completion cycle. */
    maxToolCalls?: number;
    /** Optional description for documentation purposes, aiding in agent usage understanding. */
    docDescription?: string;
    /** The unique name of the agent within the swarm. */
    agentName: AgentName;
    /** The name of the completion mechanism used by the agent. */
    completion: CompletionName;
    /** The primary prompt guiding the agent's behavior. */
    prompt: string;
    /** Optional array of system prompts, typically used for tool-calling protocols. */
    system?: string[];
    /** Optional array of tool names available to the agent. */
    tools?: ToolName[];
    /** Optional array of storage names utilized by the agent. */
    storages?: StorageName[];
    /** Optional array of state names managed by the agent. */
    states?: StateName[];
    /** Optional array of agent names this agent depends on for transitions (e.g., via changeToAgent). */
    dependsOn?: AgentName[];
    /**
     * Optional function to validate the agent's output before finalization.
     * @param {string} output - The output string to validate.
     * @returns {Promise<string | null>} A promise resolving to the validated output or null if invalid.
     */
    validate?: (output: string) => Promise<string | null>;
    /**
     * Optional function to transform the model's output before further processing.
     * @param {string} input - The raw input from the model.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<string> | string} The transformed output string.
     */
    transform?: (input: string, clientId: string, agentName: AgentName) => Promise<string> | string;
    /**
     * Optional function to map assistant messages, e.g., converting JSON to tool calls for specific models.
     * @param {IModelMessage} message - The assistant message to process.
     * @param {string} clientId - The ID of the client interacting with the agent.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<IModelMessage> | IModelMessage} The transformed assistant message.
     */
    map?: (message: IModelMessage, clientId: string, agentName: AgentName) => Promise<IModelMessage> | IModelMessage;
    /** Optional lifecycle callbacks for the agent, allowing customization of execution flow. */
    callbacks?: Partial<IAgentSchemaCallbacks>;
}
/**
 * Interface representing an agent's runtime behavior and interaction methods.
 * Defines how the agent processes inputs, commits messages, and manages its lifecycle.
 */
interface IAgent {
    /**
     * Runs the agent statelessly without modifying chat history.
     * Useful for one-off computations or previews.
     * @param {string} input - The input string to process.
     * @returns {Promise<string>} A promise resolving to the agent's output.
     * @throws {Error} If execution fails due to invalid input or internal errors.
     */
    run: (input: string) => Promise<string>;
    /**
     * Executes the agent with the given input, potentially updating history based on mode.
     * @param {string} input - The input string to process.
     * @param {ExecutionMode} mode - The execution source (e.g., "tool" or "user").
     * @returns {Promise<void>} A promise that resolves when execution is complete.
     * @throws {Error} If execution fails due to invalid input, tools, or internal errors.
     */
    execute: (input: string, mode: ExecutionMode) => Promise<void>;
    /**
     * Waits for and retrieves the agent's output after execution.
     * @returns {Promise<string>} A promise resolving to the output string.
     * @throws {Error} If no output is available or waiting times out.
     */
    waitForOutput: () => Promise<string>;
    /**
     * Commits tool output to the agent's history or state.
     * @param {string} toolId - The unique `tool_call_id` for tracking in OpenAI-style history.
     * @param {string} content - The output content from the tool.
     * @returns {Promise<void>} A promise that resolves when the output is committed.
     * @throws {Error} If the tool ID is invalid or committing fails.
     */
    commitToolOutput(toolId: string, content: string): Promise<void>;
    /**
     * Commits a system message to the agent's history or state.
     * @param {string} message - The system message content to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     * @throws {Error} If committing the message fails.
     */
    commitSystemMessage(message: string): Promise<void>;
    /**
     * Commits a user message to the agent's history without triggering a response.
     * @param {string} message - The user message content to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     * @throws {Error} If committing the message fails.
     */
    commitUserMessage(message: string): Promise<void>;
    /**
     * Commits an assistant message to the agent's history without triggering a response.
     * @param {string} message - The assistant message content to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     * @throws {Error} If committing the message fails.
     */
    commitAssistantMessage(message: string): Promise<void>;
    /**
     * Clears the agent's history, resetting it to an initial state.
     * @returns {Promise<void>} A promise that resolves when the history is flushed.
     * @throws {Error} If flushing the history fails.
     */
    commitFlush(): Promise<void>;
    /**
     * Prevents the next tool in the execution sequence from running and stops further tool calls.
     * @returns {Promise<void>} A promise that resolves when the stop is committed.
     * @throws {Error} If stopping the tools fails.
     */
    commitStopTools(): Promise<void>;
    /**
     * Unlocks the execution queue and signals an agent change, stopping subsequent tool executions.
     * @returns {Promise<void>} A promise that resolves when the agent change is committed.
     * @throws {Error} If committing the agent change fails.
     */
    commitAgentChange(): Promise<void>;
}
/**
 * Type representing the unique name of an agent within the swarm.
 * @typedef {string} AgentName
 */
type AgentName = string;
/**
 * Type representing the unique name of a tool within the swarm.
 * @typedef {string} ToolName
 */
type ToolName = string;

/**
 * Interface representing the context.
 */
interface IMethodContext {
    clientId: string;
    methodName: string;
    agentName: AgentName;
    swarmName: SwarmName;
    storageName: StorageName;
    stateName: StateName;
    policyName: PolicyName;
}
/**
 * Service providing method call context information.
 */
declare const MethodContextService: (new () => {
    readonly context: IMethodContext;
}) & Omit<{
    new (context: IMethodContext): {
        readonly context: IMethodContext;
    };
}, "prototype"> & di_scoped.IScopedClassRun<[context: IMethodContext]>;

/**
 * LoggerService class that implements the ILogger interface.
 * Provides methods to log and debug messages.
 */
declare class LoggerService implements ILogger {
    private readonly methodContextService;
    private readonly executionContextService;
    private _commonLogger;
    /**
     * Creates the client logs adapter using factory
     */
    private getLoggerAdapter;
    /**
     * Logs messages using the current logger.
     * @param {...any} args - The messages to log.
     */
    log: (topic: string, ...args: any[]) => void;
    /**
     * Logs debug messages using the current logger.
     * @param {...any} args - The debug messages to log.
     */
    debug: (topic: string, ...args: any[]) => void;
    /**
     * Logs info messages using the current logger.
     * @param {...any} args - The info messages to log.
     */
    info: (topic: string, ...args: any[]) => void;
    /**
     * Sets a new logger.
     * @param {ILogger} logger - The new logger to set.
     */
    setLogger: (logger: ILogger) => void;
}

declare const AGENT_CHANGE_SYMBOL: unique symbol;
declare const MODEL_RESQUE_SYMBOL: unique symbol;
declare const TOOL_ERROR_SYMBOL: unique symbol;
declare const TOOL_STOP_SYMBOL: unique symbol;
/**
 * Represents a client agent that interacts with the system, managing message execution, tool calls, and history.
 * @implements {IAgent}
 */
declare class ClientAgent implements IAgent {
    readonly params: IAgentParams;
    readonly _agentChangeSubject: Subject<typeof AGENT_CHANGE_SYMBOL>;
    readonly _resqueSubject: Subject<typeof MODEL_RESQUE_SYMBOL>;
    readonly _toolErrorSubject: Subject<typeof TOOL_ERROR_SYMBOL>;
    readonly _toolStopSubject: Subject<typeof TOOL_STOP_SYMBOL>;
    readonly _toolCommitSubject: Subject<void>;
    readonly _outputSubject: Subject<string>;
    /**
     * Creates an instance of ClientAgent.
     * @param {IAgentParams} params - The parameters for initializing the agent.
     */
    constructor(params: IAgentParams);
    /**
     * Emits the transformed output after validation, invoking callbacks and emitting events.
     * If validation fails, attempts to resurrect the model and revalidate.
     * @param {ExecutionMode} mode - The execution mode (e.g., user or tool).
     * @param {string} rawResult - The raw result to be transformed and emitted.
     * @returns {Promise<void>}
     * @throws {Error} If validation fails after model resurrection.
     * @private
     */
    _emitOutput(mode: ExecutionMode, rawResult: string): Promise<void>;
    /**
     * Resurrects the model in case of failures by applying configured strategies (e.g., flush, recomplete, custom).
     * Updates the history and returns a placeholder or transformed result.
     * @param {ExecutionMode} mode - The execution mode (e.g., user or tool).
     * @param {string} [reason="unknown"] - The reason for resurrecting the model.
     * @returns {Promise<string>} A placeholder or transformed result after resurrection.
     * @private
     */
    _resurrectModel(mode: ExecutionMode, reason?: string): Promise<string>;
    /**
     * Waits for the output to be available and returns it.
     * @returns {Promise<string>} The output emitted by the agent.
     */
    waitForOutput(): Promise<string>;
    /**
     * Retrieves a completion message from the model based on the current history and tools.
     * Handles validation and applies resurrection strategies if needed.
     * @param {ExecutionMode} mode - The execution mode (e.g., user or tool).
     * @returns {Promise<IModelMessage>} The completion message from the model.
     */
    getCompletion(mode: ExecutionMode): Promise<IModelMessage>;
    /**
     * Commits a user message to the history without triggering a response.
     * @param {string} message - The user message to commit.
     * @returns {Promise<void>}
     */
    commitUserMessage(message: string): Promise<void>;
    /**
     * Commits a flush of the agent's history, clearing it and notifying the system.
     * @returns {Promise<void>}
     */
    commitFlush(): Promise<void>;
    /**
     * Signals a change in the agent to halt subsequent tool executions.
     * Emits an event to notify the system.
     * @returns {Promise<void>}
     */
    commitAgentChange(): Promise<void>;
    /**
     * Signals a stop to prevent further tool executions.
     * Emits an event to notify the system.
     * @returns {Promise<void>}
     */
    commitStopTools(): Promise<void>;
    /**
     * Commits a system message to the history and notifies the system.
     * @param {string} message - The system message to commit.
     * @returns {Promise<void>}
     */
    commitSystemMessage(message: string): Promise<void>;
    /**
     * Commits an assistant message to the history without triggering execution.
     * @param {string} message - The assistant message to commit.
     * @returns {Promise<void>}
     */
    commitAssistantMessage(message: string): Promise<void>;
    /**
     * Commits the tool output to the history and notifies the system.
     * @param {string} toolId - The ID of the tool that produced the output.
     * @param {string} content - The tool output content.
     * @returns {Promise<void>}
     */
    commitToolOutput(toolId: string, content: string): Promise<void>;
    /**
     * Executes the incoming message and processes tool calls if any.
     * Queues the execution to prevent overlapping calls.
     * @param {string} incoming - The incoming message content.
     * @param {ExecutionMode} mode - The execution mode (e.g., user or tool).
     * @returns {Promise<void>}
     */
    execute: IAgent["execute"];
    /**
     * Runs the completion statelessly and returns the transformed output.
     * Queues the execution to prevent overlapping calls.
     * @param {string} incoming - The incoming message content.
     * @returns {Promise<string>} The transformed result of the completion.
     */
    run: IAgent["run"];
    /**
     * Disposes of the agent, performing cleanup and invoking the onDispose callback.
     * @returns {Promise<void>}
     */
    dispose(): Promise<void>;
}

/**
 * Service for managing agent connections.
 * @implements {IAgent}
 */
declare class AgentConnectionService implements IAgent {
    private readonly loggerService;
    private readonly busService;
    private readonly methodContextService;
    private readonly sessionValidationService;
    private readonly historyConnectionService;
    private readonly storageConnectionService;
    private readonly stateConnectionService;
    private readonly agentSchemaService;
    private readonly toolSchemaService;
    private readonly completionSchemaService;
    /**
     * Retrieves an agent instance.
     * @param {string} clientId - The client ID.
     * @param {string} agentName - The agent name.
     * @returns {ClientAgent} The client agent instance.
     */
    getAgent: ((clientId: string, agentName: string) => ClientAgent) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, ClientAgent>;
    /**
     * Executes an input command.
     * @param {string} input - The input command.
     * @returns {Promise<any>} The execution result.
     */
    execute: (input: string, mode: ExecutionMode) => Promise<void>;
    /**
     * Run the completion stateless
     * @param {string} input - The input command.
     * @returns {Promise<any>} The execution result.
     */
    run: (input: string) => Promise<string>;
    /**
     * Waits for the output from the agent.
     * @returns {Promise<any>} The output result.
     */
    waitForOutput: () => Promise<string>;
    /**
     * Commits tool output.
     * @param {string} content - The tool output content.
     * @param {string} toolId - The `tool_call_id` for openai history
     * @returns {Promise<any>} The commit result.
     */
    commitToolOutput: (toolId: string, content: string) => Promise<void>;
    /**
     * Commits an assistant message.
     * @param {string} message - The assistant message.
     * @returns {Promise<any>} The commit result.
     */
    commitSystemMessage: (message: string) => Promise<void>;
    /**
     * Commits a system message.
     * @param {string} message - The system message.
     * @returns {Promise<any>} The commit result.
     */
    commitAssistantMessage: (message: string) => Promise<void>;
    /**
     * Commits a user message without answer.
     * @param {string} message - The message.
     * @returns {Promise<any>} The commit result.
     */
    commitUserMessage: (message: string) => Promise<void>;
    /**
     * Commits agent change to prevent the next tool execution from being called.
     * @returns {Promise<any>} The commit result.
     */
    commitAgentChange: () => Promise<void>;
    /**
     * Prevent the next tool from being executed
     * @returns {Promise<any>} The commit result.
     */
    commitStopTools: () => Promise<void>;
    /**
     * Commits flush of agent history
     * @returns {Promise<any>} The commit result.
     */
    commitFlush: () => Promise<void>;
    /**
     * Disposes of the agent connection.
     * @returns {Promise<void>} The dispose result.
     */
    dispose: () => Promise<void>;
}

/**
 * Class representing the history of client messages, managing storage and retrieval of messages.
 * @implements {IHistory}
 */
declare class ClientHistory implements IHistory {
    readonly params: IHistoryParams;
    /**
     * Filter condition function for `toArrayForAgent`, used to filter messages based on agent-specific criteria.
     */
    _filterCondition: (message: IModelMessage) => boolean;
    /**
     * Creates an instance of ClientHistory.
     * Initializes the filter condition based on global configuration.
     * @param {IHistoryParams} params - The parameters for initializing the history.
     */
    constructor(params: IHistoryParams);
    /**
     * Pushes a message into the history and emits a corresponding event.
     * @param {IModelMessage} message - The message to add to the history.
     * @returns {Promise<void>}
     */
    push(message: IModelMessage): Promise<void>;
    /**
     * Removes and returns the most recent message from the history.
     * Emits an event with the popped message or null if the history is empty.
     * @returns {Promise<IModelMessage | null>} The most recent message, or null if the history is empty.
     */
    pop(): Promise<IModelMessage | null>;
    /**
     * Converts the history into an array of raw messages without any filtering or transformation.
     * @returns {Promise<IModelMessage[]>} An array of raw messages in the history.
     */
    toArrayForRaw(): Promise<IModelMessage[]>;
    /**
     * Converts the history into an array of messages tailored for the agent.
     * Filters messages based on the agent's filter condition, limits the number of messages,
     * and prepends prompt and system messages.
     * @param {string} prompt - The initial prompt message to prepend.
     * @param {string[] | undefined} system - Optional array of additional system messages to prepend.
     * @returns {Promise<IModelMessage[]>} An array of messages formatted for the agent.
     */
    toArrayForAgent(prompt: string, system?: string[]): Promise<IModelMessage[]>;
    /**
     * Disposes of the history, performing cleanup and releasing resources.
     * Should be called when the agent is being disposed.
     * @returns {Promise<void>}
     */
    dispose(): Promise<void>;
}

/**
 * Service for managing history connections.
 * @implements {IHistory}
 */
declare class HistoryConnectionService implements IHistory {
    private readonly loggerService;
    private readonly busService;
    private readonly methodContextService;
    private readonly sessionValidationService;
    /**
     * Retrieves the history for a given client and agent.
     * @param {string} clientId - The client ID.
     * @param {string} agentName - The agent name.
     * @returns {ClientHistory} The client history.
     */
    getHistory: ((clientId: string, agentName: string) => ClientHistory) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, ClientHistory>;
    /**
     * Pushes a message to the history.
     * @param {IModelMessage} message - The message to push.
     * @returns {Promise<void>} A promise that resolves when the message is pushed.
     */
    push: (message: IModelMessage) => Promise<void>;
    /**
     * Pop a message from the history.
     * @returns {Promise<IModelMessage | null>} A promise that resolves when the message is popped.
     */
    pop: () => Promise<IModelMessage>;
    /**
     * Converts the history to an array for the agent.
     * @param {string} prompt - The prompt.
     * @returns {Promise<any[]>} A promise that resolves to an array for the agent.
     */
    toArrayForAgent: (prompt: string) => Promise<IModelMessage[]>;
    /**
     * Converts the history to a raw array.
     * @returns {Promise<any[]>} A promise that resolves to a raw array.
     */
    toArrayForRaw: () => Promise<IModelMessage[]>;
    /**
     * Disposes of the history connection service.
     * @returns {Promise<void>} A promise that resolves when the service is disposed.
     */
    dispose: () => Promise<void>;
}

/**
 * Service for managing agent schemas.
 */
declare class AgentSchemaService {
    readonly loggerService: LoggerService;
    private registry;
    /**
     * Validation for agent schema
     */
    private validateShallow;
    /**
     * Registers a new agent schema.
     * @param {AgentName} key - The name of the agent.
     * @param {IAgentSchema} value - The schema of the agent.
     */
    register: (key: AgentName, value: IAgentSchema) => void;
    /**
     * Retrieves an agent schema by name.
     * @param {AgentName} key - The name of the agent.
     * @returns {IAgentSchema} The schema of the agent.
     */
    get: (key: AgentName) => IAgentSchema;
}

/**
 * Service for managing tool schemas.
 */
declare class ToolSchemaService {
    private readonly loggerService;
    private registry;
    /**
     * Validation for state schema
     */
    private validateShallow;
    /**
     * Registers a tool with the given key and value.
     * @param {ToolName} key - The name of the tool.
     * @param {IAgentTool} value - The tool to register.
     */
    register: (key: ToolName, value: IAgentTool) => void;
    /**
     * Retrieves a tool by its key.
     * @param {ToolName} key - The name of the tool.
     * @returns {IAgentTool} The tool associated with the given key.
     */
    get: (key: ToolName) => IAgentTool;
}

declare const AGENT_NEED_FETCH: unique symbol;
declare const STACK_NEED_FETCH: unique symbol;
/**
 * Manages a collection of agents within a swarm, handling agent switching, output waiting, and navigation.
 * @implements {ISwarm}
 */
declare class ClientSwarm implements ISwarm {
    readonly params: ISwarmParams;
    /**
     * Subject that emits when an agent reference changes, providing the agent name and instance.
     */
    _agentChangedSubject: Subject<[agentName: string, agent: IAgent]>;
    /**
     * The name of the currently active agent, or a symbol indicating it needs to be fetched.
     */
    _activeAgent: AgentName | typeof AGENT_NEED_FETCH;
    /**
     * The navigation stack of agent names, or a symbol indicating it needs to be fetched.
     */
    _navigationStack: AgentName[] | typeof STACK_NEED_FETCH;
    /**
     * Subject that emits to cancel output waiting, providing an empty output string.
     */
    _cancelOutputSubject: Subject<{
        agentName: string;
        output: string;
    }>;
    /**
     * Getter for the list of agent name-agent pairs from the agent map.
     * @returns {[string, IAgent][]} An array of tuples containing agent names and their instances.
     */
    get _agentList(): [string, IAgent][];
    /**
     * Creates an instance of ClientSwarm.
     * @param {ISwarmParams} params - The parameters for initializing the swarm, including agent map and callbacks.
     */
    constructor(params: ISwarmParams);
    /**
     * Pops the most recent agent from the navigation stack or returns the default agent if empty.
     * Updates the persisted navigation stack.
     * @returns {Promise<string>} The name of the previous agent, or the default agent if the stack is empty.
     */
    navigationPop(): Promise<string>;
    /**
     * Cancels the current output wait by emitting an empty string via the cancel subject.
     * @returns {Promise<void>} A promise that resolves when the cancellation is complete.
     */
    cancelOutput(): Promise<void>;
    /**
     * Waits for output from the active agent in a queued manner.
     * Handles cancellation and agent changes, ensuring only one wait operation at a time.
     * @returns {Promise<string>} The output from the active agent, or an empty string if canceled.
     */
    waitForOutput: () => Promise<string>;
    /**
     * Retrieves the name of the active agent, fetching it if not yet loaded.
     * Emits an event with the result.
     * @returns {Promise<AgentName>} The name of the active agent.
     */
    getAgentName(): Promise<AgentName>;
    /**
     * Retrieves the active agent instance based on its name.
     * Emits an event with the result.
     * @returns {Promise<IAgent>} The active agent instance.
     */
    getAgent(): Promise<IAgent>;
    /**
     * Updates the reference to an agent in the swarm's agent map.
     * Notifies subscribers via the agent changed subject.
     * @param {AgentName} agentName - The name of the agent to update.
     * @param {IAgent} agent - The new agent instance.
     * @throws {Error} If the agent name is not found in the swarm's agent map.
     * @returns {Promise<void>} A promise that resolves when the update is complete.
     */
    setAgentRef(agentName: AgentName, agent: IAgent): Promise<void>;
    /**
     * Sets the active agent by name, updates the navigation stack, and persists the change.
     * Invokes the onAgentChanged callback if provided.
     * @param {AgentName} agentName - The name of the agent to set as active.
     * @returns {Promise<void>} A promise that resolves when the agent is set and persisted.
     */
    setAgentName(agentName: AgentName): Promise<void>;
}

/**
 * Service for managing swarm connections.
 * @implements {ISwarm}
 */
declare class SwarmConnectionService implements ISwarm {
    private readonly loggerService;
    private readonly busService;
    private readonly methodContextService;
    private readonly agentConnectionService;
    private readonly swarmSchemaService;
    /**
     * Retrieves a swarm instance based on client ID and swarm name.
     * @param {string} clientId - The client ID.
     * @param {string} swarmName - The swarm name.
     * @returns {ClientSwarm} The client swarm instance.
     */
    getSwarm: ((clientId: string, swarmName: string) => ClientSwarm) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, ClientSwarm>;
    /**
     * Pop the navigation stack or return default agent
     * @returns {Promise<string>} - The pending agent for navigation
     */
    navigationPop: () => Promise<string>;
    /**
     * Cancel the await of output by emit of empty string
     * @returns {Promise<void>}
     */
    cancelOutput: () => Promise<void>;
    /**
     * Waits for the output from the swarm.
     * @returns {Promise<any>} The output from the swarm.
     */
    waitForOutput: () => Promise<string>;
    /**
     * Retrieves the agent name from the swarm.
     * @returns {Promise<string>} The agent name.
     */
    getAgentName: () => Promise<string>;
    /**
     * Retrieves the agent from the swarm.
     * @returns {Promise<IAgent>} The agent instance.
     */
    getAgent: () => Promise<IAgent>;
    /**
     * Sets the agent reference in the swarm.
     * @param {AgentName} agentName - The name of the agent.
     * @param {IAgent} agent - The agent instance.
     * @returns {Promise<void>}
     */
    setAgentRef: (agentName: AgentName, agent: IAgent) => Promise<void>;
    /**
     * Sets the agent name in the swarm.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<void>}
     */
    setAgentName: (agentName: AgentName) => Promise<void>;
    /**
     * Disposes of the swarm connection.
     * @returns {Promise<void>}
     */
    dispose: () => Promise<void>;
}

/**
 * Service for managing swarm schemas.
 */
declare class SwarmSchemaService {
    readonly loggerService: LoggerService;
    private registry;
    /**
     * Validation for swarm schema
     */
    private validateShallow;
    /**
     * Registers a new swarm schema.
     * @param {SwarmName} key - The name of the swarm.
     * @param {ISwarmSchema} value - The schema of the swarm.
     */
    register: (key: SwarmName, value: ISwarmSchema) => void;
    /**
     * Retrieves a swarm schema by its name.
     * @param {SwarmName} key - The name of the swarm.
     * @returns {ISwarmSchema} The schema of the swarm.
     */
    get: (key: SwarmName) => ISwarmSchema;
}

/**
 * Service for managing completion schemas.
 */
declare class CompletionSchemaService {
    readonly loggerService: LoggerService;
    private registry;
    /**
     * Validation for completion schemaschema
     */
    private validateShallow;
    /**
     * Registers a new completion schema.
     * @param {CompletionName} key - The key for the schema.
     * @param {ICompletionSchema} value - The schema to register.
     */
    register: (key: CompletionName, value: ICompletionSchema) => void;
    /**
     * Retrieves a completion schema by key.
     * @param {CompletionName} key - The key of the schema to retrieve.
     * @returns {ICompletionSchema} The retrieved schema.
     */
    get: (key: CompletionName) => ICompletionSchema;
}

/**
 * Represents a client session for managing message execution, emission, and agent interactions.
 * @implements {ISession}
 */
declare class ClientSession implements ISession {
    readonly params: ISessionParams;
    /**
     * Subject for emitting output messages to subscribers.
     */
    readonly _emitSubject: Subject<string>;
    /**
     * Constructs a new ClientSession instance.
     * Invokes the onInit callback if provided.
     * @param {ISessionParams} params - The parameters for initializing the session.
     */
    constructor(params: ISessionParams);
    /**
     * Emits a message to subscribers after validating it against the policy.
     * If validation fails, emits the ban message instead.
     * @param {string} message - The message to emit.
     * @returns {Promise<void>}
     */
    emit(message: string): Promise<void>;
    /**
     * Executes a message using the swarm's agent and returns the output.
     * Validates input and output against the policy, returning a ban message if either fails.
     * @param {string} message - The message to execute.
     * @param {ExecutionMode} mode - The execution mode (e.g., "user" or "tool").
     * @returns {Promise<string>} The output of the execution, or a ban message if validation fails.
     */
    execute(message: string, mode: ExecutionMode): Promise<string>;
    /**
     * Runs a stateless completion of a message using the swarm's agent and returns the output.
     * Does not emit the result but logs the execution via the event bus.
     * @param {string} message - The message to run.
     * @returns {Promise<string>} The output of the completion.
     */
    run(message: string): Promise<string>;
    /**
     * Commits tool output to the agent's history via the swarm.
     * @param {string} toolId - The ID of the tool call (e.g., `tool_call_id` for OpenAI history).
     * @param {string} content - The tool output content to commit.
     * @returns {Promise<void>}
     */
    commitToolOutput(toolId: string, content: string): Promise<void>;
    /**
     * Commits a user message to the agent's history without triggering a response.
     * @param {string} message - The user message to commit.
     * @returns {Promise<void>}
     */
    commitUserMessage(message: string): Promise<void>;
    /**
     * Commits a flush of the agent's history, clearing it.
     * @returns {Promise<void>}
     */
    commitFlush(): Promise<void>;
    /**
     * Signals the agent to stop the execution of subsequent tools.
     * @returns {Promise<void>}
     */
    commitStopTools(): Promise<void>;
    /**
     * Commits a system message to the agent's history.
     * @param {string} message - The system message to commit.
     * @returns {Promise<void>}
     */
    commitSystemMessage(message: string): Promise<void>;
    /**
     * Commits an assistant message to the agent's history without triggering execution.
     * @param {string} message - The assistant message to commit.
     * @returns {Promise<void>}
     */
    commitAssistantMessage(message: string): Promise<void>;
    /**
     * Connects the session to a message connector, subscribing to emitted messages and returning a receiver function.
     * @param {SendMessageFn} connector - The function to handle outgoing messages.
     * @returns {ReceiveMessageFn<string>} A function to receive incoming messages and process them.
     */
    connect(connector: SendMessageFn$1): ReceiveMessageFn<string>;
    /**
     * Disposes of the session, performing cleanup and invoking the onDispose callback if provided.
     * Should be called when the session is no longer needed.
     * @returns {Promise<void>}
     */
    dispose(): Promise<void>;
}

/**
 * Service for managing session connections.
 * @implements {ISession}
 */
declare class SessionConnectionService implements ISession {
    private readonly loggerService;
    private readonly busService;
    private readonly methodContextService;
    private readonly swarmConnectionService;
    private readonly policyConnectionService;
    private readonly swarmSchemaService;
    /**
     * Retrieves a memoized session based on clientId and swarmName.
     * @param {string} clientId - The client ID.
     * @param {string} swarmName - The swarm name.
     * @returns {ClientSession} The client session.
     */
    getSession: ((clientId: string, swarmName: string) => ClientSession) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, ClientSession>;
    /**
     * Emits a message to the session.
     * @param {string} content - The content to emit.
     * @returns {Promise<void>} A promise that resolves when the message is emitted.
     */
    emit: (content: string) => Promise<void>;
    /**
     * Executes a command in the session.
     * @param {string} content - The content to execute.
     * @returns {Promise<string>} A promise that resolves with the execution result.
     */
    execute: (content: string, mode: ExecutionMode) => Promise<string>;
    /**
     * Run the completion stateless
     * @param {string} content - The content to execute.
     * @returns {Promise<string>} A promise that resolves with the execution result.
     */
    run: (content: string) => Promise<string>;
    /**
     * Connects to the session using the provided connector.
     * @param {SendMessageFn} connector - The function to send messages.
     * @returns {ReceiveMessageFn} The function to receive messages.
     */
    connect: (connector: SendMessageFn$1, clientId: string, swarmName: SwarmName) => ReceiveMessageFn<string>;
    /**
     * Commits tool output to the session.
     * @param {string} toolId - The `tool_call_id` for openai history
     * @param {string} content - The content to commit.
     * @returns {Promise<void>} A promise that resolves when the content is committed.
     */
    commitToolOutput: (toolId: string, content: string) => Promise<void>;
    /**
     * Commits a system message to the session.
     * @param {string} message - The message to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     */
    commitSystemMessage: (message: string) => Promise<void>;
    /**
     * Commits an assistant message to the session.
     * @param {string} message - The message to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     */
    commitAssistantMessage: (message: string) => Promise<void>;
    /**
     * Commits user message to the agent without answer.
     * @param {string} message - The message to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     */
    commitUserMessage: (message: string) => Promise<void>;
    /**
     * Commits user message to the agent without answer.
     * @param {string} message - The message to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     */
    commitFlush: () => Promise<void>;
    /**
     * Commits user message to the agent without answer.
     * @param {string} message - The message to commit.
     * @returns {Promise<void>} A promise that resolves when the message is committed.
     */
    commitStopTools: () => Promise<void>;
    /**
     * Disposes of the session connection service.
     * @returns {Promise<void>} A promise that resolves when the service is disposed.
     */
    dispose: () => Promise<void>;
}

interface IAgentConnectionService extends AgentConnectionService {
}
type InternalKeys$8 = keyof {
    getAgent: never;
};
type TAgentConnectionService = {
    [key in Exclude<keyof IAgentConnectionService, InternalKeys$8>]: unknown;
};
/**
 * Service for managing public agent operations.
 */
declare class AgentPublicService implements TAgentConnectionService {
    private readonly loggerService;
    private readonly agentConnectionService;
    /**
     * Creates a reference to an agent.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The agent reference.
     */
    createAgentRef: (methodName: string, clientId: string, agentName: AgentName) => Promise<ClientAgent>;
    /**
     * Executes a command on the agent.
     * @param {string} input - The input command.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The execution result.
     */
    execute: (input: string, mode: ExecutionMode, methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Run the completion stateless
     * @param {string} input - The input command.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The execution result.
     */
    run: (input: string, methodName: string, clientId: string, agentName: AgentName) => Promise<string>;
    /**
     * Waits for the agent's output.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The output result.
     */
    waitForOutput: (methodName: string, clientId: string, agentName: AgentName) => Promise<string>;
    /**
     * Commits tool output to the agent.
     * @param {string} toolId - The `tool_call_id` for openai history
     * @param {string} content - The content to commit.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The commit result.
     */
    commitToolOutput: (toolId: string, content: string, methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Commits a system message to the agent.
     * @param {string} message - The message to commit.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The commit result.
     */
    commitSystemMessage: (message: string, methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Commits an assistant message to the agent history.
     * @param {string} message - The message to commit.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The commit result.
     */
    commitAssistantMessage: (message: string, methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Commits user message to the agent without answer.
     * @param {string} message - The message to commit.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The commit result.
     */
    commitUserMessage: (message: string, methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Commits flush of agent history
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The commit result.
     */
    commitFlush: (methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Commits change of agent to prevent the next tool execution from being called.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The commit result.
     */
    commitAgentChange: (methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Prevent the next tool from being executed
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The commit result.
     */
    commitStopTools: (methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Disposes of the agent.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {Promise<unknown>} The dispose result.
     */
    dispose: (methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
}

interface IHistoryConnectionService extends HistoryConnectionService {
}
type InternalKeys$7 = keyof {
    getHistory: never;
    getItems: never;
};
type THistoryConnectionService = {
    [key in Exclude<keyof IHistoryConnectionService, InternalKeys$7>]: unknown;
};
/**
 * Service for handling public history operations.
 */
declare class HistoryPublicService implements THistoryConnectionService {
    private readonly loggerService;
    private readonly historyConnectionService;
    /**
     * Pushes a message to the history.
     * @param {IModelMessage} message - The message to push.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The agent name.
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     */
    push: (message: IModelMessage, methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
    /**
     * Pushes a message to the history.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The agent name.
     * @returns {Promise<IModelMessage | null>} A promise that resolves when the operation is complete.
     */
    pop: (methodName: string, clientId: string, agentName: AgentName) => Promise<IModelMessage>;
    /**
     * Converts history to an array for a specific agent.
     * @param {string} prompt - The prompt.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The agent name.
     * @returns {Promise<any[]>} A promise that resolves to an array of history items.
     */
    toArrayForAgent: (prompt: string, methodName: string, clientId: string, agentName: AgentName) => Promise<IModelMessage[]>;
    /**
     * Converts history to a raw array.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The agent name.
     * @returns {Promise<any[]>} A promise that resolves to a raw array of history items.
     */
    toArrayForRaw: (methodName: string, clientId: string, agentName: AgentName) => Promise<IModelMessage[]>;
    /**
     * Disposes of the history.
     * @param {string} clientId - The client ID.
     * @param {AgentName} agentName - The agent name.
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     */
    dispose: (methodName: string, clientId: string, agentName: AgentName) => Promise<void>;
}

interface ISessionConnectionService extends SessionConnectionService {
}
type InternalKeys$6 = keyof {
    getSession: never;
};
type TSessionConnectionService = {
    [key in Exclude<keyof ISessionConnectionService, InternalKeys$6>]: unknown;
};
/**
 * Service for managing public session interactions.
 */
declare class SessionPublicService implements TSessionConnectionService {
    private readonly loggerService;
    private readonly perfService;
    private readonly sessionConnectionService;
    private readonly busService;
    /**
     * Emits a message to the session.
     * @param {string} content - The content to emit.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    emit: (content: string, methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
    /**
     * Executes a command in the session.
     * @param {string} content - The content to execute.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    execute: (content: string, mode: ExecutionMode, methodName: string, clientId: string, swarmName: SwarmName) => Promise<string>;
    /**
     * Run the completion stateless
     * @param {string} content - The content to execute.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    run: (content: string, methodName: string, clientId: string, swarmName: SwarmName) => Promise<string>;
    /**
     * Connects to the session.
     * @param {SendMessageFn} connector - The function to send messages.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {ReceiveMessageFn}
     */
    connect: (connector: SendMessageFn$1, methodName: string, clientId: string, swarmName: SwarmName) => ReceiveMessageFn<string>;
    /**
     * Commits tool output to the session.
     * @param {string} toolId - The `tool_call_id` for openai history
     * @param {string} content - The content to commit.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    commitToolOutput: (toolId: string, content: string, methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
    /**
     * Commits a system message to the session.
     * @param {string} message - The message to commit.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    commitSystemMessage: (message: string, methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
    /**
     * Commits an assistant message to the session.
     * @param {string} message - The message to commit.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>``}
     */
    commitAssistantMessage: (message: string, methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
    /**
     * Commits user message to the agent without answer.
     * @param {string} message - The message to commit.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    commitUserMessage: (message: string, methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
    /**
     * Commits flush of agent history
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    commitFlush: (methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
    /**
     * Prevent the next tool from being executed
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    commitStopTools: (methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
    /**
     * Disposes of the session.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    dispose: (methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
}

interface ISwarmConnectionService extends SwarmConnectionService {
}
type InternalKeys$5 = keyof {
    getSwarm: never;
};
type TSwarmConnectionService = {
    [key in Exclude<keyof ISwarmConnectionService, InternalKeys$5>]: unknown;
};
/**
 * Service for managing public swarm interactions.
 */
declare class SwarmPublicService implements TSwarmConnectionService {
    private readonly loggerService;
    private readonly swarmConnectionService;
    /**
     * Pop the navigation stack or return default agent
     * @returns {Promise<string>} - The pending agent for navigation
     */
    navigationPop: (methodName: string, clientId: string, swarmName: SwarmName) => Promise<string>;
    /**
     * Cancel the await of output by emit of empty string
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    cancelOutput: (methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
    /**
     * Waits for output from the swarm.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    waitForOutput: (methodName: string, clientId: string, swarmName: SwarmName) => Promise<string>;
    /**
     * Gets the agent name from the swarm.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<string>}
     */
    getAgentName: (methodName: string, clientId: string, swarmName: SwarmName) => Promise<string>;
    /**
     * Gets the agent from the swarm.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<IAgent>}
     */
    getAgent: (methodName: string, clientId: string, swarmName: SwarmName) => Promise<IAgent>;
    /**
     * Sets the agent reference in the swarm.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @param {AgentName} agentName - The agent name.
     * @param {IAgent} agent - The agent instance.
     * @returns {Promise<void>}
     */
    setAgentRef: (methodName: string, clientId: string, swarmName: SwarmName, agentName: AgentName, agent: IAgent) => Promise<void>;
    /**
     * Sets the agent name in the swarm.
     * @param {AgentName} agentName - The agent name.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    setAgentName: (agentName: AgentName, methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
    /**
     * Disposes of the swarm.
     * @param {string} clientId - The client ID.
     * @param {SwarmName} swarmName - The swarm name.
     * @returns {Promise<void>}
     */
    dispose: (methodName: string, clientId: string, swarmName: SwarmName) => Promise<void>;
}

/**
 * Service for validating agents within the agent swarm.
 */
declare class AgentValidationService {
    private readonly loggerService;
    private readonly toolValidationService;
    private readonly completionValidationService;
    private readonly storageValidationService;
    private _agentMap;
    private _agentDepsMap;
    getAgentList: () => string[];
    /**
     * Retrieves the storages used by the agent
     * @param {agentName} agentName - The name of the swarm.
     * @returns {string[]} The list of storage names.
     * @throws Will throw an error if the swarm is not found.
     */
    getStorageList: (agentName: string) => string[];
    /**
     * Retrieves the states used by the agent
     * @param {agentName} agentName - The name of the swarm.
     * @returns {string[]} The list of state names.
     * @throws Will throw an error if the swarm is not found.
     */
    getStateList: (agentName: string) => string[];
    /**
     * Adds a new agent to the validation service.
     * @param {AgentName} agentName - The name of the agent.
     * @param {IAgentSchema} agentSchema - The schema of the agent.
     * @throws {Error} If the agent already exists.
     */
    addAgent: (agentName: AgentName, agentSchema: IAgentSchema) => void;
    /**
     * Check if agent got registered storage
     */
    hasStorage: ((agentName: AgentName, storageName: StorageName) => boolean) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, boolean>;
    /**
     * Check if agent got registered dependency
     */
    hasDependency: ((targetAgentName: AgentName, depAgentName: StorageName) => boolean) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, boolean>;
    /**
     * Check if agent got registered state
     */
    hasState: ((agentName: AgentName, stateName: StateName) => boolean) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, boolean>;
    /**
     * Validates an agent by its name and source.
     * @param {AgentName} agentName - The name of the agent.
     * @param {string} source - The source of the validation request.
     * @throws {Error} If the agent is not found.
     */
    validate: (agentName: AgentName, source: string) => void;
}

/**
 * Service for validating tools within the agent-swarm.
 */
declare class ToolValidationService {
    private readonly loggerService;
    private _toolMap;
    /**
     * Adds a new tool to the validation service.
     * @param {ToolName} toolName - The name of the tool to add.
     * @param {IAgentTool} toolSchema - The schema of the tool to add.
     * @throws Will throw an error if the tool already exists.
     */
    addTool: (toolName: ToolName, toolSchema: IAgentTool) => void;
    /**
     * Validates if a tool exists in the validation service.
     * @param {ToolName} toolName - The name of the tool to validate.
     * @param {string} source - The source of the validation request.
     * @throws Will throw an error if the tool is not found.
     */
    validate: (toolName: ToolName, source: string) => void;
}

/**
 * Service for validating and managing sessions.
 */
declare class SessionValidationService {
    private readonly loggerService;
    private _storageSwarmMap;
    private _historySwarmMap;
    private _agentSwarmMap;
    private _stateSwarmMap;
    private _sessionSwarmMap;
    private _sessionModeMap;
    /**
     * Adds a new session.
     * @param {SessionId} clientId - The ID of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {SessionMode} sessionMode - The mode of the session.
     * @throws Will throw an error if the session already exists.
     */
    addSession: (clientId: SessionId, swarmName: SwarmName, sessionMode: SessionMode) => void;
    /**
     * Adds an agent usage to a session.
     * @param {SessionId} sessionId - The ID of the session.
     * @param {AgentName} agentName - The name of the agent.
     */
    addAgentUsage: (sessionId: SessionId, agentName: AgentName) => void;
    /**
     * Adds a history usage to a session.
     * @param {SessionId} sessionId - The ID of the session.
     * @param {AgentName} agentName - The name of the agent.
     */
    addHistoryUsage: (sessionId: SessionId, agentName: AgentName) => void;
    /**
     * Adds a storage usage to a session.
     * @param {SessionId} sessionId - The ID of the session.
     * @param {StorageName} storageName - The name of the storage.
     */
    addStorageUsage: (sessionId: SessionId, storageName: StorageName) => void;
    /**
     * Adds a state usage to a session.
     * @param {SessionId} sessionId - The ID of the session.
     * @param {StateName} stateName - The name of the state.
     */
    addStateUsage: (sessionId: SessionId, stateName: StateName) => void;
    /**
     * Removes an agent usage from a session.
     * @param {SessionId} sessionId - The ID of the session.
     * @param {AgentName} agentName - The name of the agent.
     * @throws Will throw an error if no agents are found for the session.
     */
    removeAgentUsage: (sessionId: SessionId, agentName: AgentName) => void;
    /**
     * Removes a history usage from a session.
     * @param {SessionId} sessionId - The ID of the session.
     * @param {AgentName} agentName - The name of the agent.
     * @throws Will throw an error if no agents are found for the session.
     */
    removeHistoryUsage: (sessionId: SessionId, agentName: AgentName) => void;
    /**
     * Removes a storage usage from a session.
     * @param {SessionId} sessionId - The ID of the session.
     * @param {StorageName} storageName - The name of the storage.
     * @throws Will throw an error if no storages are found for the session.
     */
    removeStorageUsage: (sessionId: SessionId, storageName: StorageName) => void;
    /**
     * Removes a state usage from a session.
     * @param {SessionId} sessionId - The ID of the session.
     * @param {StateName} stateName - The name of the state.
     * @throws Will throw an error if no states are found for the session.
     */
    removeStateUsage: (sessionId: SessionId, stateName: StateName) => void;
    /**
     * Gets the mode of a session.
     * @param {SessionId} clientId - The ID of the client.
     * @returns {SessionMode} The mode of the session.
     * @throws Will throw an error if the session does not exist.
     */
    getSessionMode: (clientId: SessionId) => SessionMode;
    /**
     * Ensures session is exist
     * @returns {boolean}
     */
    hasSession: (clientId: SessionId) => boolean;
    /**
     * Gets the list of all session IDs.
     * @returns {SessionId[]} The list of session IDs.
     */
    getSessionList: () => string[];
    /**
     * Gets the list of agents for a session.
     * @param {string} clientId - The ID of the client.
     * @returns {AgentName[]} The list of agent names.
     */
    getSessionAgentList: (clientId: string) => string[];
    /**
     * Gets the history list of agents for a session.
     * @param {string} clientId - The ID of the client.
     * @returns {AgentName[]} The list of agent names.
     */
    getSessionHistoryList: (clientId: string) => string[];
    /**
     * Gets the swarm name for a session.
     * @param {SessionId} clientId - The ID of the client.
     * @returns {SwarmName} The name of the swarm.
     * @throws Will throw an error if the session does not exist.
     */
    getSwarm: (clientId: SessionId) => string;
    /**
     * Validates if a session exists.
     * @param {SessionId} clientId - The ID of the client.
     * @param {string} source - The source of the validation request.
     * @throws Will throw an error if the session does not exist.
     */
    validate: ((clientId: SessionId, source: string) => void) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, void>;
    /**
     * Removes a session.
     * @param {SessionId} clientId - The ID of the client.
     */
    removeSession: (clientId: SessionId) => void;
    /**
     * Dispose a session validation cache.
     * @param {SessionId} clientId - The ID of the client.
     */
    dispose: (clientId: string) => void;
}

/**
 * Service for validating swarms and their agents.
 */
declare class SwarmValidationService {
    private readonly loggerService;
    private readonly agentValidationService;
    private readonly policyValidationService;
    private _swarmMap;
    /**
     * Adds a new swarm to the swarm map.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {ISwarmSchema} swarmSchema - The schema of the swarm.
     * @throws Will throw an error if the swarm already exists.
     */
    addSwarm: (swarmName: SwarmName, swarmSchema: ISwarmSchema) => void;
    /**
     * Retrieves the list of agents for a given swarm.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {string[]} The list of agent names.
     * @throws Will throw an error if the swarm is not found.
     */
    getAgentList: (swarmName: SwarmName) => string[];
    /**
     * Retrieves the list of ban policies for a given swarm.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {string[]} The list of policy names.
     * @throws Will throw an error if the swarm is not found.
     */
    getPolicyList: (swarmName: SwarmName) => string[];
    /**
     * Retrieves the list of swarms
     * @returns {string[]} The list of swarm names
     */
    getSwarmList: () => string[];
    /**
     * Validates a swarm and its agents.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {string} source - The source of the validation request.
     * @throws Will throw an error if the swarm is not found or if the default agent is not in the agent list.
     */
    validate: (swarmName: SwarmName, source: string) => void;
}

/**
 * Service for validating completion names.
 */
declare class CompletionValidationService {
    private readonly loggerService;
    private _completionSet;
    /**
     * Adds a new completion name to the set.
     * @param {CompletionName} completionName - The name of the completion to add.
     * @throws Will throw an error if the completion name already exists.
     */
    addCompletion: (completionName: CompletionName) => void;
    /**
     * Validates if a completion name exists in the set.
     * @param {CompletionName} completionName - The name of the completion to validate.
     * @param {string} source - The source of the validation request.
     * @throws Will throw an error if the completion name is not found.
     */
    validate: (completionName: CompletionName, source: string) => void;
}

/**
 * Service for managing embedding schemas.
 */
declare class EmbeddingSchemaService {
    private readonly loggerService;
    private registry;
    /**
     * Validation for embedding schema
     */
    private validateShallow;
    /**
     * Registers a embedding with the given key and value.
     * @param {EmbeddingName} key - The name of the embedding.
     * @param {IAgentTool} value - The embedding to register.
     */
    register: (key: EmbeddingName, value: IEmbeddingSchema) => void;
    /**
     * Retrieves a embedding by its key.
     * @param {EmbeddingName} key - The name of the embedding.
     * @returns {IAgentTool} The embedding associated with the given key.
     */
    get: (key: EmbeddingName) => IEmbeddingSchema;
}

/**
 * Service for managing storage schemas.
 */
declare class StorageSchemaService {
    readonly loggerService: LoggerService;
    private registry;
    /**
     * Validation for storage schema
     */
    private validateShallow;
    /**
     * Registers a new storage schema.
     * @param {StorageName} key - The key for the schema.
     * @param {IStorageSchema} value - The schema to register.
     */
    register: (key: StorageName, value: IStorageSchema) => void;
    /**
     * Retrieves a storage schema by key.
     * @param {StorageName} key - The key of the schema to retrieve.
     * @returns {IStorageSchema} The retrieved schema.
     */
    get: (key: StorageName) => IStorageSchema;
}

/**
 * Type representing possible storage actions.
 */
type Action = "upsert" | "remove" | "clear";
/**
 * Type representing the payload for storage actions.
 * @template T - The type of storage data, extending IStorageData.
 */
type Payload<T extends IStorageData = IStorageData> = {
    /** The ID of the item. */
    itemId: IStorageData["id"];
    /** The item data to upsert. */
    item: T;
};
/**
 * Class managing storage operations with embedding-based search capabilities.
 * Supports upserting, removing, and searching items with similarity scoring.
 * @template T - The type of storage data, extending IStorageData.
 * @implements {IStorage<T>}
 */
declare class ClientStorage<T extends IStorageData = IStorageData> implements IStorage<T> {
    readonly params: IStorageParams<T>;
    /** Internal map to store items by their IDs. */
    _itemMap: Map<string | number, T>;
    /**
     * Creates an instance of ClientStorage.
     * Invokes the onInit callback if provided.
     * @param {IStorageParams<T>} params - The storage parameters, including client ID, storage name, and callback functions.
     */
    constructor(params: IStorageParams<T>);
    /**
     * Dispatches a storage action (upsert, remove, or clear) in a queued manner.
     * @param {Action} action - The action to perform ("upsert", "remove", or "clear").
     * @param {Partial<Payload<T>>} payload - The payload for the action (item or itemId).
     * @returns {Promise<void>} A promise that resolves when the action is complete.
     */
    dispatch: (action: Action, payload: Partial<Payload<T>>) => Promise<void>;
    /**
     * Creates embeddings for the given item, memoized by item ID to avoid redundant calculations.
     * @param {T} item - The item to create embeddings for.
     * @returns {Promise<readonly [any, any]>} A tuple of embeddings and index.
     * @private
     */
    _createEmbedding: ((item: T) => Promise<readonly [Embeddings, string]>) & functools_kit.IClearableMemoize<string | number> & functools_kit.IControlMemoize<string | number, Promise<readonly [Embeddings, string]>>;
    /**
     * Waits for the initialization of the storage, loading initial data and creating embeddings.
     * Ensures initialization happens only once using singleshot.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    waitForInit: (() => Promise<void>) & functools_kit.ISingleshotClearable;
    /**
     * Retrieves a specified number of items based on similarity to a search string.
     * Uses embeddings and similarity scoring to sort and filter results.
     * @param {string} search - The search string to compare against stored items.
     * @param {number} total - The maximum number of items to return.
     * @param {number} [score=GLOBAL_CONFIG.CC_STORAGE_SEARCH_SIMILARITY] - The minimum similarity score for items to be included (defaults to global config).
     * @returns {Promise<T[]>} An array of items sorted by similarity, limited to the specified total and score threshold.
     */
    take(search: string, total: number, score?: number): Promise<T[]>;
    /**
     * Upserts an item into the storage via the dispatch queue.
     * @param {T} item - The item to upsert.
     * @returns {Promise<void>} A promise that resolves when the upsert operation is complete.
     */
    upsert(item: T): Promise<void>;
    /**
     * Removes an item from the storage by its ID via the dispatch queue.
     * @param {IStorageData["id"]} itemId - The ID of the item to remove.
     * @returns {Promise<void>} A promise that resolves when the remove operation is complete.
     */
    remove(itemId: IStorageData["id"]): Promise<void>;
    /**
     * Clears all items from the storage via the dispatch queue.
     * @returns {Promise<void>} A promise that resolves when the clear operation is complete.
     */
    clear(): Promise<void>;
    /**
     * Retrieves an item from the storage by its ID.
     * Emits an event with the result.
     * @param {IStorageData["id"]} itemId - The ID of the item to retrieve.
     * @returns {Promise<T | null>} The item if found, or null if not found.
     */
    get(itemId: IStorageData["id"]): Promise<T | null>;
    /**
     * Lists all items in the storage, optionally filtered by a predicate.
     * Emits an event with the filtered result if a filter is provided.
     * @param {(item: T) => boolean} [filter] - An optional predicate to filter items.
     * @returns {Promise<T[]>} An array of items, filtered if a predicate is provided.
     */
    list(filter?: (item: T) => boolean): Promise<T[]>;
    /**
     * Disposes of the storage instance, invoking the onDispose callback if provided.
     * @returns {Promise<void>} A promise that resolves when disposal is complete.
     */
    dispose(): Promise<void>;
}

/**
 * Service for managing storage connections.
 * @implements {IStorage}
 */
declare class StorageConnectionService implements IStorage {
    private readonly loggerService;
    private readonly busService;
    private readonly methodContextService;
    private readonly storageSchemaService;
    private readonly sessionValidationService;
    private readonly embeddingSchemaService;
    private readonly sharedStorageConnectionService;
    private _sharedStorageSet;
    /**
     * Retrieves a storage instance based on client ID and storage name.
     * @param {string} clientId - The client ID.
     * @param {string} storageName - The storage name.
     * @returns {ClientStorage} The client storage instance.
     */
    getStorage: ((clientId: string, storageName: StorageName) => ClientStorage<any>) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, ClientStorage<any>>;
    /**
     * Retrieves a list of storage data based on a search query and total number of items.
     * @param {string} search - The search query.
     * @param {number} total - The total number of items to retrieve.
     * @returns {Promise<IStorageData[]>} The list of storage data.
     */
    take: (search: string, total: number, score?: number) => Promise<IStorageData[]>;
    /**
     * Upserts an item in the storage.
     * @param {IStorageData} item - The item to upsert.
     * @returns {Promise<void>}
     */
    upsert: (item: IStorageData) => Promise<void>;
    /**
     * Removes an item from the storage.
     * @param {IStorageData["id"]} itemId - The ID of the item to remove.
     * @returns {Promise<void>}
     */
    remove: (itemId: IStorageData["id"]) => Promise<void>;
    /**
     * Retrieves an item from the storage by its ID.
     * @param {IStorageData["id"]} itemId - The ID of the item to retrieve.
     * @returns {Promise<IStorageData>} The retrieved item.
     */
    get: (itemId: IStorageData["id"]) => Promise<IStorageData | null>;
    /**
     * Retrieves a list of items from the storage, optionally filtered by a predicate function.
     * @param {function(IStorageData): boolean} [filter] - The optional filter function.
     * @returns {Promise<IStorageData[]>} The list of items.
     */
    list: (filter?: (item: IStorageData) => boolean) => Promise<IStorageData[]>;
    /**
     * Clears all items from the storage.
     * @returns {Promise<void>}
     */
    clear: () => Promise<void>;
    /**
     * Disposes of the storage connection.
     * @returns {Promise<void>}
     */
    dispose: () => Promise<void>;
}

interface IStorageConnectionService extends StorageConnectionService {
}
type InternalKeys$4 = keyof {
    getStorage: never;
    getSharedStorage: never;
};
type TStorageConnectionService = {
    [key in Exclude<keyof IStorageConnectionService, InternalKeys$4>]: unknown;
};
/**
 * Service for managing public storage interactions.
 */
declare class StoragePublicService implements TStorageConnectionService {
    private readonly loggerService;
    private readonly storageConnectionService;
    /**
     * Retrieves a list of storage data based on a search query and total number of items.
     * @param {string} search - The search query.
     * @param {number} total - The total number of items to retrieve.
     * @returns {Promise<IStorageData[]>} The list of storage data.
     */
    take: (search: string, total: number, methodName: string, clientId: string, storageName: StorageName, score?: number) => Promise<IStorageData[]>;
    /**
     * Upserts an item in the storage.
     * @param {IStorageData} item - The item to upsert.
     * @returns {Promise<void>}
     */
    upsert: (item: IStorageData, methodName: string, clientId: string, storageName: StorageName) => Promise<void>;
    /**
     * Removes an item from the storage.
     * @param {IStorageData["id"]} itemId - The ID of the item to remove.
     * @returns {Promise<void>}
     */
    remove: (itemId: IStorageData["id"], methodName: string, clientId: string, storageName: StorageName) => Promise<void>;
    /**
     * Retrieves an item from the storage by its ID.
     * @param {IStorageData["id"]} itemId - The ID of the item to retrieve.
     * @returns {Promise<IStorageData>} The retrieved item.
     */
    get: (itemId: IStorageData["id"], methodName: string, clientId: string, storageName: StorageName) => Promise<IStorageData | null>;
    /**
     * Retrieves a list of items from the storage, optionally filtered by a predicate function.
     * @param {function(IStorageData): boolean} [filter] - The optional filter function.
     * @returns {Promise<IStorageData[]>} The list of items.
     */
    list: (methodName: string, clientId: string, storageName: StorageName, filter?: (item: IStorageData) => boolean) => Promise<IStorageData[]>;
    /**
     * Clears all items from the storage.
     * @returns {Promise<void>}
     */
    clear: (methodName: string, clientId: string, storageName: StorageName) => Promise<void>;
    /**
     * Disposes of the storage.
     * @param {string} clientId - The client ID.
     * @param {StorageName} storageName - The storage name.
     * @returns {Promise<void>}
     */
    dispose: (methodName: string, clientId: string, storageName: StorageName) => Promise<void>;
}

/**
 * Service for validating storages within the storage swarm.
 */
declare class StorageValidationService {
    private readonly loggerService;
    private readonly embeddingValidationService;
    private _storageMap;
    /**
     * Adds a new storage to the validation service.
     * @param {StorageName} storageName - The name of the storage.
     * @param {IStorageSchema} storageSchema - The schema of the storage.
     * @throws {Error} If the storage already exists.
     */
    addStorage: (storageName: StorageName, storageSchema: IStorageSchema) => void;
    /**
     * Validates an storage by its name and source.
     * @param {StorageName} storageName - The name of the storage.
     * @param {string} source - The source of the validation request.
     * @throws {Error} If the storage is not found.
     */
    validate: (storageName: StorageName, source: string) => void;
}

/**
 * Service for validating embeddings within the agent-swarm.
 */
declare class EmbeddingValidationService {
    private readonly loggerService;
    private _embeddingMap;
    /**
     * Adds a new embedding to the validation service.
     * @param {EmbeddingName} embeddingName - The name of the embedding to add.
     * @param {IAgentEmbedding} embeddingSchema - The schema of the embedding to add.
     * @throws Will throw an error if the embedding already exists.
     */
    addEmbedding: (embeddingName: EmbeddingName, embeddingSchema: IEmbeddingSchema) => void;
    /**
     * Validates if a embedding exists in the validation service.
     * @param {EmbeddingName} embeddingName - The name of the embedding to validate.
     * @param {string} source - The source of the validation request.
     * @throws Will throw an error if the embedding is not found.
     */
    validate: (embeddingName: EmbeddingName, source: string) => void;
}

type DispatchFn<State extends IStateData = IStateData> = (prevState: State) => Promise<State>;
/**
 * Class representing the client state, managing state data with read/write operations.
 * @template State - The type of the state data, extending IStateData.
 * @implements {IState<State>}
 */
declare class ClientState<State extends IStateData = IStateData> implements IState<State> {
    readonly params: IStateParams<State>;
    /**
     * The current state data, initialized as null and set during waitForInit.
     */
    _state: State;
    /**
     * Queued dispatch function to read or write the state.
     * @param {string} action - The action to perform ("read" or "write").
     * @param {DispatchFn<State>} [payload] - The function to update the state (required for "write").
     * @returns {Promise<State>} The current or updated state.
     */
    dispatch: (action: string, payload?: DispatchFn<State>) => Promise<State>;
    /**
     * Creates an instance of ClientState.
     * Invokes the onInit callback if provided.
     * @param {IStateParams<State>} params - The parameters for initializing the state.
     */
    constructor(params: IStateParams<State>);
    /**
     * Waits for the state to initialize, ensuring it’s only called once.
     * Uses singleshot to prevent multiple initializations.
     * @returns {Promise<void>}
     */
    waitForInit: (() => Promise<void>) & functools_kit.ISingleshotClearable;
    /**
     * Sets the state using the provided dispatch function, applying middlewares and persisting the result.
     * Invokes the onWrite callback and emits an event if configured.
     * @param {DispatchFn<State>} dispatchFn - The function to update the state.
     * @returns {Promise<State>} The updated state.
     */
    setState(dispatchFn: DispatchFn<State>): Promise<State>;
    /**
     * Resets the state to its initial value as determined by getState and getDefaultState.
     * Persists the result and invokes the onWrite callback if configured.
     * @returns {Promise<State>} The reset state.
     */
    clearState(): Promise<State>;
    /**
     * Retrieves the current state.
     * Invokes the onRead callback and emits an event if configured.
     * @returns {Promise<State>} The current state.
     */
    getState(): Promise<State>;
    /**
     * Disposes of the state, performing cleanup and invoking the onDispose callback if provided.
     * @returns {Promise<void>}
     */
    dispose(): Promise<void>;
}

/**
 * Service for managing state connections.
 * @template T - The type of state data.
 * @implements {IState<T>}
 */
declare class StateConnectionService<T extends IStateData = IStateData> implements IState<T> {
    private readonly loggerService;
    private readonly busService;
    private readonly methodContextService;
    private readonly stateSchemaService;
    private readonly sessionValidationService;
    private readonly sharedStateConnectionService;
    private _sharedStateSet;
    /**
     * Memoized function to get a state reference.
     * @param {string} clientId - The client ID.
     * @param {StateName} stateName - The state name.
     * @returns {ClientState} The client state.
     */
    getStateRef: ((clientId: string, stateName: StateName) => ClientState<any>) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, ClientState<any>>;
    /**
     * Sets the state.
     * @param {function(T): Promise<T>} dispatchFn - The function to dispatch the new state.
     * @returns {Promise<T>} The new state.
     */
    setState: (dispatchFn: (prevState: T) => Promise<T>) => Promise<T>;
    /**
     * Set the state to initial value
     * @returns {Promise<T>} The initial state.
     */
    clearState: () => Promise<T>;
    /**
     * Gets the state.
     * @returns {Promise<T>} The current state.
     */
    getState: () => Promise<T>;
    /**
     * Disposes the state connection.
     * @returns {Promise<void>}
     */
    dispose: () => Promise<void>;
}

interface IStateConnectionService extends StateConnectionService {
}
type InternalKeys$3 = keyof {
    getStateRef: never;
    getSharedStateRef: never;
};
type TStateConnectionService = {
    [key in Exclude<keyof IStateConnectionService, InternalKeys$3>]: unknown;
};
declare class StatePublicService<T extends IStateData = IStateData> implements TStateConnectionService {
    private readonly loggerService;
    private readonly stateConnectionService;
    /**
     * Sets the state using the provided dispatch function.
     * @param {function(T): Promise<T>} dispatchFn - The function to dispatch the state change.
     * @param {string} clientId - The client ID.
     * @param {StateName} stateName - The name of the state.
     * @returns {Promise<T>} - The updated state.
     */
    setState: (dispatchFn: (prevState: T) => Promise<T>, methodName: string, clientId: string, stateName: StateName) => Promise<T>;
    /**
     * Set the state to initial value
     * @param {string} clientId - The client ID.
     * @param {StateName} stateName - The name of the state.
     * @returns {Promise<T>} - The initial state.
     */
    clearState: (methodName: string, clientId: string, stateName: StateName) => Promise<T>;
    /**
     * Gets the current state.
     * @param {string} clientId - The client ID.
     * @param {StateName} stateName - The name of the state.
     * @returns {Promise<T>} - The current state.
     */
    getState: (methodName: string, clientId: string, stateName: StateName) => Promise<T>;
    /**
     * Disposes the state.
     * @param {string} clientId - The client ID.
     * @param {StateName} stateName - The name of the state.
     * @returns {Promise<void>} - A promise that resolves when the state is disposed.
     */
    dispose: (methodName: string, clientId: string, stateName: StateName) => Promise<void>;
}

/**
 * Service for managing state schemas.
 */
declare class StateSchemaService {
    readonly loggerService: LoggerService;
    private registry;
    /**
     * Validation for state schema
     */
    private validateShallow;
    /**
     * Registers a new state schema.
     * @param {StateName} key - The key for the schema.
     * @param {IStateSchema} value - The schema to register.
     */
    register: (key: StateName, value: IStateSchema) => void;
    /**
     * Retrieves a state schema by key.
     * @param {StateName} key - The key of the schema to retrieve.
     * @returns {IStateSchema} The retrieved schema.
     */
    get: (key: StateName) => IStateSchema;
}

declare class BusService implements IBus {
    private readonly loggerService;
    private readonly sessionValidationService;
    private _eventSourceSet;
    private _eventWildcardMap;
    private getEventSubject;
    /**
     * Subscribes to events for a specific client and source.
     * @param {string} clientId - The client ID.
     * @param {EventSource} source - The event source.
     * @param {(event: T) => void} fn - The callback function to handle the event.
     */
    subscribe: <T extends IBaseEvent>(clientId: string, source: EventSource, fn: (event: T) => void) => () => void;
    /**
     * Subscribes to a single event for a specific client and source.
     * @param {string} clientId - The client ID.
     * @param {EventSource} source - The event source.
     * @param {(event: T) => boolean} filterFn - The filter function to determine if the event should be handled.
     * @param {(event: T) => void} fn - The callback function to handle the event.
     * @returns {Subscription} The subscription object.
     */
    once: <T extends IBaseEvent>(clientId: string, source: EventSource, filterFn: (event: T) => boolean, fn: (event: T) => void) => () => void;
    /**
     * Emits an event for a specific client.
     * @param {string} clientId - The client ID.
     * @param {T} event - The event to emit.
     * @returns {Promise<void>} A promise that resolves when the event has been emitted.
     */
    emit: <T extends IBaseEvent>(clientId: string, event: T) => Promise<void>;
    /**
     * Alias to emit the execution begin event
     */
    commitExecutionBegin: (clientId: string, context: Partial<IBusEventContext>) => Promise<void>;
    /**
     * Alias to emit the execution end event
     */
    commitExecutionEnd: (clientId: string, context: Partial<IBusEventContext>) => Promise<void>;
    /**
     * Disposes of all event subscriptions for a specific client.
     * @param {string} clientId - The client ID.
     */
    dispose: (clientId: string) => void;
}

/**
 * Interface representing a meta node.
 */
interface IMetaNode {
    name: string;
    child?: IMetaNode[];
}
/**
 * Service class for managing agent meta nodes and converting them to UML format.
 */
declare class AgentMetaService {
    private readonly loggerService;
    private readonly agentSchemaService;
    private serialize;
    /**
     * Creates a meta node for the given agent.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {IMetaNode} The created meta node.
     */
    makeAgentNode: (agentName: AgentName, seen?: Set<string>) => IMetaNode;
    /**
     * Creates a meta node for the given agent.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {IMetaNode} The created meta node.
     */
    makeAgentNodeCommon: (agentName: AgentName, seen?: Set<string>) => IMetaNode;
    /**
     * Converts the meta nodes of the given agent to UML format.
     * @param {AgentName} agentName - The name of the agent.
     * @returns {string} The UML representation of the agent's meta nodes.
     */
    toUML: (agentName: AgentName, withSubtree?: boolean) => string;
}

/**
 * Service for handling swarm metadata.
 */
declare class SwarmMetaService {
    private readonly loggerService;
    private readonly swarmSchemaService;
    private readonly agentMetaService;
    private serialize;
    /**
     * Creates a swarm node with the given swarm name.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {IMetaNode} The metadata node of the swarm.
     */
    makeSwarmNode: (swarmName: SwarmName) => IMetaNode;
    /**
     * Converts the swarm metadata to UML format.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {string} The UML representation of the swarm.
     */
    toUML: (swarmName: SwarmName) => string;
}

/**
 * Service for generating documentation for swarms and agents.
 * @class
 */
declare class DocService {
    private readonly loggerService;
    private readonly perfService;
    private readonly swarmValidationService;
    private readonly agentValidationService;
    private readonly swarmSchemaService;
    private readonly agentSchemaService;
    private readonly policySchemaService;
    private readonly toolSchemaService;
    private readonly storageSchemaService;
    private readonly stateSchemaService;
    private readonly agentMetaService;
    private readonly swarmMetaService;
    /**
     * Writes documentation for a swarm schema.
     * @param {ISwarmSchema} swarmSchema - The swarm schema to document.
     * @param {string} dirName - The directory to write the documentation to.
     * @returns {Promise<void>}
     */
    private writeSwarmDoc;
    /**
     * Writes documentation for an agent schema.
     * @param {IAgentSchema} agentSchema - The agent schema to document.
     * @param {string} dirName - The directory to write the documentation to.
     * @returns {Promise<void>}
     */
    private writeAgentDoc;
    /**
     * Dumps the documentation for all swarms and agents.
     * @param {string} [dirName=join(process.cwd(), "docs/chat")] - The directory to write the documentation to.
     * @returns {Promise<void>}
     */
    dumpDocs: (dirName?: string) => Promise<void>;
    /**
     * Dumps the performance data to a file.
     * @param {string} [dirName=join(process.cwd(), "docs/meta")] - The directory to write the performance data to.
     * @returns {Promise<void>}
     */
    dumpPerfomance: (dirName?: string) => Promise<void>;
    /**
     * Dumps the client performance data to a file.
     * @param {string} clientId - The session id to dump the data
     * @param {string} [dirName=join(process.cwd(), "docs/meta")] - The directory to write the performance data to.
     * @returns {Promise<void>}
     */
    dumpClientPerfomance: (clientId: string, dirName?: string) => Promise<void>;
}

/**
 * Service for managing storage connections.
 * @implements {IStorage}
 */
declare class SharedStorageConnectionService implements IStorage {
    private readonly loggerService;
    private readonly busService;
    private readonly methodContextService;
    private readonly storageSchemaService;
    private readonly embeddingSchemaService;
    /**
     * Retrieves a storage instance based on client ID and storage name.
     * @param {string} clientId - The client ID.
     * @param {string} storageName - The storage name.
     * @returns {ClientStorage} The client storage instance.
     */
    getStorage: ((storageName: StorageName) => ClientStorage<any>) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, ClientStorage<any>>;
    /**
     * Retrieves a list of storage data based on a search query and total number of items.
     * @param {string} search - The search query.
     * @param {number} total - The total number of items to retrieve.
     * @returns {Promise<IStorageData[]>} The list of storage data.
     */
    take: (search: string, total: number, score?: number) => Promise<IStorageData[]>;
    /**
     * Upserts an item in the storage.
     * @param {IStorageData} item - The item to upsert.
     * @returns {Promise<void>}
     */
    upsert: (item: IStorageData) => Promise<void>;
    /**
     * Removes an item from the storage.
     * @param {IStorageData["id"]} itemId - The ID of the item to remove.
     * @returns {Promise<void>}
     */
    remove: (itemId: IStorageData["id"]) => Promise<void>;
    /**
     * Retrieves an item from the storage by its ID.
     * @param {IStorageData["id"]} itemId - The ID of the item to retrieve.
     * @returns {Promise<IStorageData>} The retrieved item.
     */
    get: (itemId: IStorageData["id"]) => Promise<IStorageData | null>;
    /**
     * Retrieves a list of items from the storage, optionally filtered by a predicate function.
     * @param {function(IStorageData): boolean} [filter] - The optional filter function.
     * @returns {Promise<IStorageData[]>} The list of items.
     */
    list: (filter?: (item: IStorageData) => boolean) => Promise<IStorageData[]>;
    /**
     * Clears all items from the storage.
     * @returns {Promise<void>}
     */
    clear: () => Promise<void>;
}

/**
 * Service for managing shared state connections.
 * @template T - The type of state data.
 * @implements {IState<T>}
 */
declare class SharedStateConnectionService<T extends IStateData = IStateData> implements IState<T> {
    private readonly loggerService;
    private readonly busService;
    private readonly methodContextService;
    private readonly stateSchemaService;
    /**
     * Memoized function to get a shared state reference.
     * @param {string} clientId - The client ID.
     * @param {StateName} stateName - The state name.
     * @returns {ClientState} The client state.
     */
    getStateRef: ((stateName: StateName) => ClientState<any>) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, ClientState<any>>;
    /**
     * Sets the state.
     * @param {function(T): Promise<T>} dispatchFn - The function to dispatch the new state.
     * @returns {Promise<T>} The new state.
     */
    setState: (dispatchFn: (prevState: T) => Promise<T>) => Promise<T>;
    /**
     * Set the state to initial value
     * @returns {Promise<T>} The new state.
     */
    clearState: () => Promise<T>;
    /**
     * Gets the state.
     * @returns {Promise<T>} The current state.
     */
    getState: () => Promise<T>;
}

interface ISharedStateConnectionService extends SharedStateConnectionService {
}
type InternalKeys$2 = keyof {
    getStateRef: never;
    getSharedStateRef: never;
};
type TSharedStateConnectionService = {
    [key in Exclude<keyof ISharedStateConnectionService, InternalKeys$2>]: unknown;
};
declare class SharedStatePublicService<T extends IStateData = IStateData> implements TSharedStateConnectionService {
    private readonly loggerService;
    private readonly sharedStateConnectionService;
    /**
     * Sets the state using the provided dispatch function.
     * @param {function(T): Promise<T>} dispatchFn - The function to dispatch the state change.
     * @param {StateName} stateName - The name of the state.
     * @returns {Promise<T>} - The updated state.
     */
    setState: (dispatchFn: (prevState: T) => Promise<T>, methodName: string, stateName: StateName) => Promise<T>;
    /**
     * Set the state to initial value
     * @param {StateName} stateName - The name of the state.
     * @returns {Promise<T>} - The initial state.
     */
    clearState: (methodName: string, stateName: StateName) => Promise<T>;
    /**
     * Gets the current state.
     * @param {StateName} stateName - The name of the state.
     * @returns {Promise<T>} - The current state.
     */
    getState: (methodName: string, stateName: StateName) => Promise<T>;
}

interface ISharedStorageConnectionService extends SharedStorageConnectionService {
}
type InternalKeys$1 = keyof {
    getStorage: never;
    getSharedStorage: never;
};
type TSharedStorageConnectionService = {
    [key in Exclude<keyof ISharedStorageConnectionService, InternalKeys$1>]: unknown;
};
/**
 * Service for managing public storage interactions.
 */
declare class SharedStoragePublicService implements TSharedStorageConnectionService {
    private readonly loggerService;
    private readonly sharedStorageConnectionService;
    /**
     * Retrieves a list of storage data based on a search query and total number of items.
     * @param {string} search - The search query.
     * @param {number} total - The total number of items to retrieve.
     * @returns {Promise<IStorageData[]>} The list of storage data.
     */
    take: (search: string, total: number, methodName: string, storageName: StorageName, score?: number) => Promise<IStorageData[]>;
    /**
     * Upserts an item in the storage.
     * @param {IStorageData} item - The item to upsert.
     * @returns {Promise<void>}
     */
    upsert: (item: IStorageData, methodName: string, storageName: StorageName) => Promise<void>;
    /**
     * Removes an item from the storage.
     * @param {IStorageData["id"]} itemId - The ID of the item to remove.
     * @returns {Promise<void>}
     */
    remove: (itemId: IStorageData["id"], methodName: string, storageName: StorageName) => Promise<void>;
    /**
     * Retrieves an item from the storage by its ID.
     * @param {IStorageData["id"]} itemId - The ID of the item to retrieve.
     * @returns {Promise<IStorageData>} The retrieved item.
     */
    get: (itemId: IStorageData["id"], methodName: string, storageName: StorageName) => Promise<IStorageData | null>;
    /**
     * Retrieves a list of items from the storage, optionally filtered by a predicate function.
     * @param {function(IStorageData): boolean} [filter] - The optional filter function.
     * @returns {Promise<IStorageData[]>} The list of items.
     */
    list: (methodName: string, storageName: StorageName, filter?: (item: IStorageData) => boolean) => Promise<IStorageData[]>;
    /**
     * Clears all items from the storage.
     * @returns {Promise<void>}
     */
    clear: (methodName: string, storageName: StorageName) => Promise<void>;
}

/**
 * Service to manage memory schema for different sessions.
 */
declare class MemorySchemaService {
    private readonly loggerService;
    private memoryMap;
    /**
     * Writes a value to the memory map for a given client ID.
     *
     * @template T - The type of the value to be written.
     * @param {string} clientId - The ID of the client.
     * @param {T} value - The value to be written.
     */
    writeValue: <T extends object = object>(clientId: string, value: T) => T;
    /**
     * Reads a value from the memory map for a given client ID.
     *
     * @template T - The type of the value to be read.
     * @param {string} clientId - The ID of the client.
     * @returns {T} - The value associated with the client ID.
     */
    readValue: <T extends object = object>(clientId: string) => T;
    /**
     * Disposes the memory map entry for a given client ID.
     *
     * @param {string} clientId - The ID of the client.
     */
    dispose: (clientId: string) => void;
}

/**
 * Interface representing a performance record for a process within the swarm system.
 * Aggregates execution and response metrics across multiple clients (e.g., sessions or agent instances) for a specific process, likely used for system-wide performance monitoring or diagnostics.
 * Integrated into components like logging (e.g., ILogger in ClientAgent) or event buses (e.g., IBus.emit) to track operational efficiency, such as total execution counts, response times, and temporal context.
 */
interface IPerformanceRecord {
    /**
     * The unique identifier of the process being monitored.
     * Represents a specific execution context, such as a swarm run, agent workflow, or session batch, distinguishing it from other processes in the system.
     * Example: A UUID or incremental ID like "proc-123" tied to a ClientAgent execution cycle.
     * @type {string}
     */
    processId: string;
    /**
     * Array of performance records for individual clients involved in the process.
     * Each entry details metrics for a specific client (e.g., a session or agent instance), enabling granular analysis of performance across the swarm.
     * Populated with IClientPerfomanceRecord objects, reflecting per-client execution and resource usage.
     * @type {IClientPerfomanceRecord[]}
     */
    clients: IClientPerfomanceRecord[];
    /**
     * The total number of executions performed across all clients in the process.
     * Counts discrete operations (e.g., command executions in ClientAgent.execute, tool calls), providing a measure of overall activity volume.
     * Example: 50 if 5 clients each executed 10 commands.
     * @type {number}
     */
    totalExecutionCount: number;
    /**
     * The total response time for the process, formatted as a string.
     * Represents the cumulative duration of all client responses (e.g., from command start to output in ClientAgent), typically in a human-readable format like "500ms" or "1.23s".
     * Useful for assessing end-to-end performance across the process.
     * @type {string}
     */
    totalResponseTime: string;
    /**
     * The average response time per execution across all clients, formatted as a string.
     * Calculated as totalResponseTime divided by totalExecutionCount, providing a normalized performance metric (e.g., "10ms" per execution).
     * Aids in identifying typical response latency for the process.
     * @type {string}
     */
    averageResponseTime: string;
    /**
     * The number of days since January 1, 1970 (Unix epoch), based on London time (UTC).
     * Serves as a coarse timestamp for when the performance record was created, aligning with historical date tracking conventions.
     * Example: 19737 for a date in 2024, calculated as floor(Date.now() / 86400000).
     * @type {number}
     */
    momentStamp: number;
    /**
     * The number of seconds since midnight (00:00 UTC) of the day specified by momentStamp.
     * Provides fine-grained timing within the day, complementing momentStamp for precise event logging.
     * Example: 3600 for 01:00:00 UTC, derived from (Date.now() % 86400000) / 1000.
     * @type {number}
     */
    timeStamp: number;
    /**
     * The current date and time of the performance record in UTC format.
     * Stored as a string (e.g., "2024-03-15T12:00:00Z"), offering a human-readable timestamp for when the metrics were captured.
     * Likely used for logging or reporting alongside momentStamp and timeStamp.
     * @type {string}
     */
    date: string;
}
/**
 * Interface representing a performance record for an individual client within a process.
 * Captures detailed execution metrics, memory, and state for a specific client (e.g., a session or agent instance), used to analyze performance at the client level.
 * Embedded within IPerformanceRecord.clients to provide per-client breakdowns, likely logged via ILogger or emitted via IBus for monitoring (e.g., in ClientAgent workflows).
 */
interface IClientPerfomanceRecord {
    /**
     * The unique identifier of the client, typically a session or agent-specific ID.
     * Matches the clientId used in runtime params (e.g., this.params.clientId in ClientAgent), linking performance data to a specific session or agent instance.
     * Example: "client-456" for a user session.
     * @type {string}
     */
    clientId: string;
    /**
     * A key-value record of the client’s session memory.
     * Stores arbitrary data (e.g., cached values, temporary variables) used during the client’s operation, similar to IState’s state management in ClientAgent.
     * Example: `{ "cacheKey": "value" }` for a session’s temporary storage.
     * @type {Record<string, unknown>}
     */
    sessionMemory: Record<string, unknown>;
    /**
     * A key-value record of the client’s session state.
     * Represents persistent state data (e.g., configuration, current step) for the client, akin to IState’s role in tracking agent state in ClientAgent.
     * Example: `{ "step": 3, "active": true }` for a session’s current status.
     * @type {Record<string, unknown>}
     */
    sessionState: Record<string, unknown>;
    /**
     * The number of executions performed by this client within the process.
     * Counts operations like command runs (e.g., ClientAgent.execute) or tool calls, contributing to the process’s totalExecutionCount.
     * Example: 10 for a client that executed 10 commands.
     * @type {number}
     */
    executionCount: number;
    /**
     * The total input size processed during executions, in a numeric unit (e.g., bytes, characters).
     * Measures the cumulative input data (e.g., incoming messages in ClientAgent.execute), useful for assessing data throughput.
     * Example: 1024 for 1KB of total input across executions.
     * @type {number}
     */
    executionInputTotal: number;
    /**
     * The total output size generated during executions, in a numeric unit (e.g., bytes, characters).
     * Measures the cumulative output data (e.g., results in ClientAgent._emitOutput), indicating response volume.
     * Example: 2048 for 2KB of total output.
     * @type {number}
     */
    executionOutputTotal: number;
    /**
     * The average input size per execution, in a numeric unit (e.g., bytes, characters).
     * Calculated as executionInputTotal divided by executionCount, providing a normalized input metric.
     * Example: 102.4 for an average of 102.4 bytes per execution.
     * @type {number}
     */
    executionInputAverage: number;
    /**
     * The average output size per execution, in a numeric unit (e.g., bytes, characters).
     * Calculated as executionOutputTotal divided by executionCount, offering insight into typical output size.
     * Example: 204.8 for an average of 204.8 bytes per execution.
     * @type {number}
     */
    executionOutputAverage: number;
    /**
     * The total execution time for the client, formatted as a string.
     * Represents the cumulative duration of all executions (e.g., from incoming to output in ClientAgent.execute), typically in a readable format like "300ms" or "1.5s".
     * Contributes to the process’s totalResponseTime.
     * @type {string}
     */
    executionTimeTotal: string;
    /**
     * The average execution time per execution, formatted as a string.
     * Calculated as executionTimeTotal divided by executionCount, providing a normalized latency metric (e.g., "30ms" per execution).
     * Helps evaluate client-specific performance efficiency.
     * @type {string}
     */
    executionTimeAverage: string;
}

/**
 * Service class for tracking and logging performance metrics of client sessions in the swarm system.
 * Monitors execution times, input/output lengths, and session states, aggregating data into IPerformanceRecord and IClientPerfomanceRecord structures.
 * Integrates with ClientAgent workflows (e.g., execute, run) to measure performance, using LoggerService for logging (gated by GLOBAL_CONFIG.CC_LOGGER_ENABLE_INFO) and validation/public services for state computation.
 * Provides methods to start/end executions, retrieve metrics, and serialize performance data for reporting or analytics.
 */
declare class PerfService {
    /**
     * Logger service instance for logging performance-related information, injected via DI.
     * Controlled by GLOBAL_CONFIG.CC_LOGGER_ENABLE_INFO, used across methods (e.g., startExecution, toRecord) for info-level logging.
     * @type {LoggerService}
     * @private
     */
    private readonly loggerService;
    /**
     * Session validation service instance, injected via DI.
     * Used to retrieve session lists (e.g., getActiveSessions) and swarm names (e.g., computeClientState).
     * @type {SessionValidationService}
     * @private
     */
    private readonly sessionValidationService;
    /**
     * Memory schema service instance, injected via DI.
     * Provides session memory data for toClientRecord, aligning with IClientPerfomanceRecord.sessionMemory.
     * @type {MemorySchemaService}
     * @private
     */
    private readonly memorySchemaService;
    /**
     * Swarm validation service instance, injected via DI.
     * Retrieves agent and policy lists for computeClientState, supporting swarm-level state aggregation.
     * @type {SwarmValidationService}
     * @private
     */
    private readonly swarmValidationService;
    /**
     * Agent validation service instance, injected via DI.
     * Fetches state lists for agents in computeClientState, enabling client state computation.
     * @type {AgentValidationService}
     * @private
     */
    private readonly agentValidationService;
    /**
     * State public service instance, injected via DI.
     * Retrieves state values for computeClientState, populating IClientPerfomanceRecord.sessionState.
     * @type {StatePublicService}
     * @private
     */
    private readonly statePublicService;
    /**
     * Swarm public service instance, injected via DI.
     * Provides agent names for computeClientState, supporting swarm status in sessionState.
     * @type {SwarmPublicService}
     * @private
     */
    private readonly swarmPublicService;
    /**
     * Policy public service instance, injected via DI.
     * Checks for bans in computeClientState, contributing to policyBans in sessionState.
     * @type {PolicyPublicService}
     * @private
     */
    private readonly policyPublicService;
    /**
     * State connection service instance, injected via DI.
     * Verifies state references in computeClientState, ensuring valid state retrieval.
     * @type {StateConnectionService}
     * @private
     */
    private readonly stateConnectionService;
    /**
     * Map tracking execution start times for clients, keyed by clientId and executionId.
     * Used in startExecution and endExecution to calculate response times per execution.
     * @type {Map<string, Map<string, number[]>>}
     * @private
     */
    private executionScheduleMap;
    /**
     * Map of total output lengths per client, keyed by clientId.
     * Updated in endExecution, used for IClientPerfomanceRecord.executionOutputTotal.
     * @type {Map<string, number>}
     * @private
     */
    private executionOutputLenMap;
    /**
     * Map of total input lengths per client, keyed by clientId.
     * Updated in startExecution, used for IClientPerfomanceRecord.executionInputTotal.
     * @type {Map<string, number>}
     * @private
     */
    private executionInputLenMap;
    /**
     * Map of execution counts per client, keyed by clientId.
     * Updated in startExecution, used for IClientPerfomanceRecord.executionCount.
     * @type {Map<string, number>}
     * @private
     */
    private executionCountMap;
    /**
     * Map of total execution times per client, keyed by clientId.
     * Updated in endExecution, used for IClientPerfomanceRecord.executionTimeTotal.
     * @type {Map<string, number>}
     * @private
     */
    private executionTimeMap;
    /**
     * Total response time across all executions, in milliseconds.
     * Aggregated in endExecution, used for IPerformanceRecord.totalResponseTime.
     * @type {number}
     * @private
     */
    private totalResponseTime;
    /**
     * Total number of execution requests across all clients.
     * Incremented in endExecution, used for IPerformanceRecord.totalExecutionCount.
     * @type {number}
     * @private
     */
    private totalRequestCount;
    /**
     * Computes the aggregated state of a client by collecting swarm, agent, policy, and state data.
     * Used in toClientRecord to populate IClientPerfomanceRecord.sessionState, integrating with validation and public services.
     * Logs via loggerService if GLOBAL_CONFIG.CC_LOGGER_ENABLE_INFO is true (e.g., ClientAgent-style debug logging).
     * @param {string} clientId - The unique identifier of the client.
     * @returns {Promise<Record<string, unknown>>} A promise resolving to an object with swarm status, policy bans, and state values.
     * @private
     */
    private computeClientState;
    /**
     * Retrieves the number of active executions for a client’s session.
     * Used to monitor execution frequency, reflecting IClientPerfomanceRecord.executionCount.
     * @param {string} clientId - The unique identifier of the client.
     * @returns {number} The number of executions recorded for the client, or 0 if none.
     */
    getActiveSessionExecutionCount: (clientId: string) => number;
    /**
     * Retrieves the total execution time for a client’s sessions, in milliseconds.
     * Used for performance analysis, feeding into IClientPerfomanceRecord.executionTimeTotal.
     * @param {string} clientId - The unique identifier of the client.
     * @returns {number} The total execution time in milliseconds, or 0 if none.
     */
    getActiveSessionExecutionTotalTime: (clientId: string) => number;
    /**
     * Calculates the average execution time per execution for a client’s sessions, in milliseconds.
     * Used for performance metrics, contributing to IClientPerfomanceRecord.executionTimeAverage.
     * @param {string} clientId - The unique identifier of the client.
     * @returns {number} The average execution time in milliseconds, or 0 if no executions.
     */
    getActiveSessionExecutionAverageTime: (clientId: string) => number;
    /**
     * Calculates the average input length per execution for a client’s sessions.
     * Used for data throughput analysis, feeding into IClientPerfomanceRecord.executionInputAverage.
     * @param {string} clientId - The unique identifier of the client.
     * @returns {number} The average input length (e.g., bytes, characters), or 0 if no executions.
     */
    getActiveSessionAverageInputLength: (clientId: string) => number;
    /**
     * Calculates the average output length per execution for a client’s sessions.
     * Used for data throughput analysis, feeding into IClientPerfomanceRecord.executionOutputAverage.
     * @param {string} clientId - The unique identifier of the client.
     * @returns {number} The average output length (e.g., bytes, characters), or 0 if no executions.
     */
    getActiveSessionAverageOutputLength: (clientId: string) => number;
    /**
     * Retrieves the total input length for a client’s sessions.
     * Used for data volume tracking, aligning with IClientPerfomanceRecord.executionInputTotal.
     * @param {string} clientId - The unique identifier of the client.
     * @returns {number} The total input length (e.g., bytes, characters), or 0 if none.
     */
    getActiveSessionTotalInputLength: (clientId: string) => number;
    /**
     * Retrieves the total output length for a client’s sessions.
     * Used for data volume tracking, aligning with IClientPerfomanceRecord.executionOutputTotal.
     * @param {string} clientId - The unique identifier of the client.
     * @returns {number} The total output length (e.g., bytes, characters), or 0 if none.
     */
    getActiveSessionTotalOutputLength: (clientId: string) => number;
    /**
     * Retrieves the list of active session client IDs.
     * Sources data from sessionValidationService, used in toRecord to enumerate clients.
     * @returns {string[]} An array of client IDs with active sessions.
     */
    getActiveSessions: () => string[];
    /**
     * Calculates the average response time across all executions, in milliseconds.
     * Used for system-wide performance metrics, feeding into IPerformanceRecord.averageResponseTime.
     * @returns {number} The average response time in milliseconds, or 0 if no requests.
     */
    getAverageResponseTime: () => number;
    /**
     * Retrieves the total number of executions across all clients.
     * Used for system-wide metrics, aligning with IPerformanceRecord.totalExecutionCount.
     * @returns {number} The total execution count.
     */
    getTotalExecutionCount: () => number;
    /**
     * Retrieves the total response time across all executions, in milliseconds.
     * Used for system-wide metrics, feeding into IPerformanceRecord.totalResponseTime.
     * @returns {number} The total response time in milliseconds.
     */
    getTotalResponseTime: () => number;
    /**
     * Starts tracking an execution for a client, recording start time and input length.
     * Initializes maps and increments execution count/input length, used with endExecution to measure performance (e.g., ClientAgent.execute).
     * @param {string} executionId - The unique identifier of the execution (e.g., a command or tool call).
     * @param {string} clientId - The unique identifier of the client.
     * @param {number} inputLen - The length of the input data (e.g., bytes, characters).
     * @returns {void}
     */
    startExecution: (executionId: string, clientId: string, inputLen: number) => void;
    /**
     * Ends tracking an execution for a client, calculating response time and updating output length.
     * Pairs with startExecution to compute execution duration, updating totals for IClientPerfomanceRecord metrics.
     * @param {string} executionId - The unique identifier of the execution.
     * @param {string} clientId - The unique identifier of the client.
     * @param {number} outputLen - The length of the output data (e.g., bytes, characters).
     * @returns {boolean} True if the execution was successfully ended (start time found), false otherwise.
     */
    endExecution: (executionId: string, clientId: string, outputLen: number) => boolean;
    /**
     * Serializes performance metrics for a specific client into an IClientPerfomanceRecord.
     * Aggregates execution counts, input/output lengths, times, memory, and state, used in toRecord for per-client data.
     * @param {string} clientId - The unique identifier of the client.
     * @returns {Promise<IClientPerfomanceRecord>} A promise resolving to the client’s performance record.
     */
    toClientRecord: (clientId: string) => Promise<IClientPerfomanceRecord>;
    /**
     * Serializes performance metrics for all clients into an IPerformanceRecord.
     * Aggregates client records, total execution counts, and response times, used for system-wide performance reporting.
     * @returns {Promise<IPerformanceRecord>} A promise resolving to the complete performance record.
     */
    toRecord: () => Promise<IPerformanceRecord>;
    /**
     * Disposes of all performance data associated with a client.
     * Clears maps for the clientId, used to reset or terminate tracking (e.g., session end in ClientAgent).
     * @param {string} clientId - The unique identifier of the client.
     * @returns {void}
     */
    dispose: (clientId: string) => void;
}

/**
 * Service for managing policy schemas.
 */
declare class PolicySchemaService {
    readonly loggerService: LoggerService;
    private registry;
    /**
     * Validation for policy schema
     */
    private validateShallow;
    /**
     * Registers a new policy schema.
     * @param {PolicyName} key - The name of the policy.
     * @param {IPolicySchema} value - The schema of the policy.
     */
    register: (key: PolicyName, value: IPolicySchema) => void;
    /**
     * Retrieves an policy schema by name.
     * @param {PolicyName} key - The name of the policy.
     * @returns {IPolicySchema} The schema of the policy.
     */
    get: (key: PolicyName) => IPolicySchema;
}

/**
 * Service for validating policys within the agent-swarm.
 */
declare class PolicyValidationService {
    private readonly loggerService;
    private _policyMap;
    /**
     * Adds a new policy to the validation service.
     * @param {PolicyName} policyName - The name of the policy to add.
     * @param {IPolicySchema} policySchema - The schema of the policy to add.
     * @throws Will throw an error if the policy already exists.
     */
    addPolicy: (policyName: PolicyName, policySchema: IPolicySchema) => void;
    /**
     * Validates if a policy exists in the validation service.
     * @param {PolicyName} policyName - The name of the policy to validate.
     * @param {string} source - The source of the validation request.
     * @throws Will throw an error if the policy is not found.
     */
    validate: (policyName: PolicyName, source: string) => void;
}

declare const BAN_NEED_FETCH: unique symbol;
/**
 * Class representing a client policy for managing bans, input/output validation, and client restrictions.
 * @implements {IPolicy}
 */
declare class ClientPolicy implements IPolicy {
    readonly params: IPolicyParams;
    /**
     * Set of banned client IDs or a symbol indicating the ban list needs to be fetched.
     * Initialized as BAN_NEED_FETCH and lazily populated on first use.
     */
    _banSet: Set<SessionId> | typeof BAN_NEED_FETCH;
    /**
     * Creates an instance of ClientPolicy.
     * Invokes the onInit callback if provided.
     * @param {IPolicyParams} params - The parameters for initializing the policy.
     */
    constructor(params: IPolicyParams);
    /**
     * Checks if a client is banned for a specific swarm.
     * Lazily fetches the ban list on the first call if not already loaded.
     * @param {SessionId} clientId - The ID of the client to check.
     * @param {SwarmName} swarmName - The name of the swarm to check against.
     * @returns {Promise<boolean>} True if the client is banned, false otherwise.
     */
    hasBan(clientId: SessionId, swarmName: SwarmName): Promise<boolean>;
    /**
     * Retrieves the ban message for a client.
     * Uses a custom getBanMessage function if provided, otherwise falls back to the default ban message.
     * @param {SessionId} clientId - The ID of the client to get the ban message for.
     * @param {SwarmName} swarmName - The name of the swarm to check against.
     * @returns {Promise<string>} The ban message for the client.
     */
    getBanMessage(clientId: SessionId, swarmName: SwarmName): Promise<string>;
    /**
     * Validates an incoming message from a client.
     * Checks if the client is banned and applies the custom validation function if provided.
     * Automatically bans the client if validation fails and autoBan is enabled.
     * @param {string} incoming - The incoming message to validate.
     * @param {SessionId} clientId - The ID of the client sending the message.
     * @param {SwarmName} swarmName - The name of the swarm to validate against.
     * @returns {Promise<boolean>} True if the input is valid and the client is not banned, false otherwise.
     */
    validateInput(incoming: string, clientId: SessionId, swarmName: SwarmName): Promise<boolean>;
    /**
     * Validates an outgoing message to a client.
     * Checks if the client is banned and applies the custom validation function if provided.
     * Automatically bans the client if validation fails and autoBan is enabled.
     * @param {string} outgoing - The outgoing message to validate.
     * @param {SessionId} clientId - The ID of the client receiving the message.
     * @param {SwarmName} swarmName - The name of the swarm to validate against.
     * @returns {Promise<boolean>} True if the output is valid and the client is not banned, false otherwise.
     */
    validateOutput(outgoing: string, clientId: SessionId, swarmName: SwarmName): Promise<boolean>;
    /**
     * Bans a client, adding them to the ban set and persisting the change if setBannedClients is provided.
     * Emits a ban event and invokes the onBanClient callback if defined.
     * @param {SessionId} clientId - The ID of the client to ban.
     * @param {SwarmName} swarmName - The name of the swarm to ban the client from.
     * @returns {Promise<void>}
     */
    banClient(clientId: SessionId, swarmName: SwarmName): Promise<void>;
    /**
     * Unbans a client, removing them from the ban set and persisting the change if setBannedClients is provided.
     * Emits an unban event and invokes the onUnbanClient callback if defined.
     * @param {SessionId} clientId - The ID of the client to unban.
     * @param {SwarmName} swarmName - The name of the swarm to unban the client from.
     * @returns {Promise<void>}
     */
    unbanClient(clientId: SessionId, swarmName: SwarmName): Promise<void>;
}

/**
 * Service for managing policy connections.
 * @implements {IPolicy}
 */
declare class PolicyConnectionService implements IPolicy {
    private readonly loggerService;
    private readonly busService;
    private readonly methodContextService;
    private readonly policySchemaService;
    /**
     * Retrieves a policy based on the policy name.
     * @param {PolicyName} policyName - The name of the policy.
     * @returns {ClientPolicy} The client policy.
     */
    getPolicy: ((policyName: PolicyName) => ClientPolicy) & functools_kit.IClearableMemoize<string> & functools_kit.IControlMemoize<string, ClientPolicy>;
    /**
     * Check if got ban flag
     * @param {SessionId} clientId - The ID of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {Promise<boolean>}
     */
    hasBan: (clientId: SessionId, swarmName: SwarmName) => Promise<boolean>;
    /**
     * Retrieves the ban message for a client in a swarm.
     * @param {SessionId} clientId - The ID of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {Promise<string>} The ban message.
     */
    getBanMessage: (clientId: SessionId, swarmName: SwarmName) => Promise<string>;
    /**
     * Validates the input for a client in a swarm.
     * @param {string} incoming - The incoming input.
     * @param {SessionId} clientId - The ID of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {Promise<boolean>} Whether the input is valid.
     */
    validateInput: (incoming: string, clientId: SessionId, swarmName: SwarmName) => Promise<boolean>;
    /**
     * Validates the output for a client in a swarm.
     * @param {string} outgoing - The outgoing output.
     * @param {SessionId} clientId - The ID of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {Promise<boolean>} Whether the output is valid.
     */
    validateOutput: (outgoing: string, clientId: SessionId, swarmName: SwarmName) => Promise<boolean>;
    /**
     * Bans a client from a swarm.
     * @param {SessionId} clientId - The ID of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {Promise<void>}
     */
    banClient: (clientId: SessionId, swarmName: SwarmName) => Promise<void>;
    /**
     * Unbans a client from a swarm.
     * @param {SessionId} clientId - The ID of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @returns {Promise<void>}
     */
    unbanClient: (clientId: SessionId, swarmName: SwarmName) => Promise<void>;
}

interface IPolicyConnectionService extends PolicyConnectionService {
}
type InternalKeys = keyof {
    getPolicy: never;
};
type TPolicyConnectionService = {
    [key in Exclude<keyof IPolicyConnectionService, InternalKeys>]: unknown;
};
/**
 * Service for handling public policy operations.
 */
declare class PolicyPublicService implements TPolicyConnectionService {
    private readonly loggerService;
    private readonly policyConnectionService;
    /**
     * Check if has ban message
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {string} methodName - The name of the method.
     * @param {string} clientId - The ID of the client.
     * @param {PolicyName} policyName - The name of the policy.
     * @returns {Promise<boolean>}
     */
    hasBan: (swarmName: SwarmName, methodName: string, clientId: string, policyName: PolicyName) => Promise<boolean>;
    /**
     * Retrieves the ban message for a client in a specific swarm.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {string} methodName - The name of the method.
     * @param {string} clientId - The ID of the client.
     * @param {PolicyName} policyName - The name of the policy.
     * @returns {Promise<string>} The ban message.
     */
    getBanMessage: (swarmName: SwarmName, methodName: string, clientId: string, policyName: PolicyName) => Promise<string>;
    /**
     * Validates the input for a specific policy.
     * @param {string} incoming - The incoming data to validate.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {string} methodName - The name of the method.
     * @param {string} clientId - The ID of the client.
     * @param {PolicyName} policyName - The name of the policy.
     * @returns {Promise<boolean>} The result of the validation.
     */
    validateInput: (incoming: string, swarmName: SwarmName, methodName: string, clientId: string, policyName: PolicyName) => Promise<boolean>;
    /**
     * Validates the output for a specific policy.
     * @param {string} outgoing - The outgoing data to validate.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {string} methodName - The name of the method.
     * @param {string} clientId - The ID of the client.
     * @param {PolicyName} policyName - The name of the policy.
     * @returns {Promise<boolean>} The result of the validation.
     */
    validateOutput: (outgoing: string, swarmName: SwarmName, methodName: string, clientId: string, policyName: PolicyName) => Promise<boolean>;
    /**
     * Bans a client from a specific swarm.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {string} methodName - The name of the method.
     * @param {string} clientId - The ID of the client.
     * @param {PolicyName} policyName - The name of the policy.
     * @returns {Promise<void>}
     */
    banClient: (swarmName: SwarmName, methodName: string, clientId: string, policyName: PolicyName) => Promise<void>;
    /**
     * Unbans a client from a specific swarm.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {string} methodName - The name of the method.
     * @param {string} clientId - The ID of the client.
     * @param {PolicyName} policyName - The name of the policy.
     * @returns {Promise<void>}
     */
    unbanClient: (swarmName: SwarmName, methodName: string, clientId: string, policyName: PolicyName) => Promise<void>;
}

declare const swarm: {
    agentValidationService: AgentValidationService;
    toolValidationService: ToolValidationService;
    sessionValidationService: SessionValidationService;
    swarmValidationService: SwarmValidationService;
    completionValidationService: CompletionValidationService;
    storageValidationService: StorageValidationService;
    embeddingValidationService: EmbeddingValidationService;
    policyValidationService: PolicyValidationService;
    agentMetaService: AgentMetaService;
    swarmMetaService: SwarmMetaService;
    agentPublicService: AgentPublicService;
    historyPublicService: HistoryPublicService;
    sessionPublicService: SessionPublicService;
    swarmPublicService: SwarmPublicService;
    storagePublicService: StoragePublicService;
    sharedStoragePublicService: SharedStoragePublicService;
    statePublicService: StatePublicService<any>;
    sharedStatePublicService: SharedStatePublicService<any>;
    policyPublicService: PolicyPublicService;
    agentSchemaService: AgentSchemaService;
    toolSchemaService: ToolSchemaService;
    swarmSchemaService: SwarmSchemaService;
    completionSchemaService: CompletionSchemaService;
    embeddingSchemaService: EmbeddingSchemaService;
    storageSchemaService: StorageSchemaService;
    stateSchemaService: StateSchemaService;
    memorySchemaService: MemorySchemaService;
    policySchemaService: PolicySchemaService;
    agentConnectionService: AgentConnectionService;
    historyConnectionService: HistoryConnectionService;
    swarmConnectionService: SwarmConnectionService;
    sessionConnectionService: SessionConnectionService;
    storageConnectionService: StorageConnectionService;
    sharedStorageConnectionService: SharedStorageConnectionService;
    stateConnectionService: StateConnectionService<any>;
    sharedStateConnectionService: SharedStateConnectionService<any>;
    policyConnectionService: PolicyConnectionService;
    methodContextService: {
        readonly context: IMethodContext;
    };
    executionContextService: {
        readonly context: IExecutionContext;
    };
    docService: DocService;
    busService: BusService;
    perfService: PerfService;
    loggerService: LoggerService;
};

/**
 * Dumps the documentation for the agents and swarms.
 *
 * @param {string} [dirName="./docs/chat"] - The directory where the documentation will be dumped.
 * @param {function} [PlantUML] - An optional function to process PlantUML diagrams.
 * @returns {Promise<void>} - A promise that resolves when the documentation has been dumped.
 */
declare const dumpDocs: (dirName?: any, PlantUML?: (uml: string) => Promise<string>) => Promise<void>;

/**
 * The config for UML generation
 */
interface IConfig {
    withSubtree: boolean;
}
/**
 * Dumps the agent information into PlantUML format.
 *
 * @param {SwarmName} swarmName - The name of the swarm to be dumped.
 * @returns {string} The UML representation of the swarm.
 */
declare const dumpAgent: (agentName: string, args_1?: Partial<IConfig>) => string;

/**
 * Dumps the swarm information into PlantUML format.
 *
 * @param {SwarmName} swarmName - The name of the swarm to be dumped.
 * @returns {string} The UML representation of the swarm.
 */
declare const dumpSwarm: (swarmName: string) => string;

/**
 * Dumps the performance data using the swarm's document service.
 * Logs the method name if logging is enabled in the global configuration.
 *
 * @param {string} [dirName="./logs/meta"] - The directory name where the performance data will be dumped.
 * @returns {Promise<void>} A promise that resolves when the performance data has been dumped.
 */
declare const dumpPerfomance: {
    (dirName?: string): Promise<void>;
    /**
     * Runs the dumpPerfomance function at specified intervals.
     * Logs the method name if logging is enabled in the global configuration.
     *
     * @param {string} [dirName="./logs/meta"] - The directory name where the performance data will be dumped.
     * @param {number} [interval=30000] - The interval in milliseconds at which to run the dumpPerfomance function.
     */
    runInterval: (dirName?: any, interval?: any) => () => void;
};

/**
 * Dumps the performance data using the swarm's document service.
 * Logs the method name if logging is enabled in the global configuration.
 *
 * @param {string} clientId - The client ID for which the performance data is being dumped.
 * @param {string} [dirName="./logs/client"] - The directory name where the performance data will be dumped.
 * @returns {Promise<void>} A promise that resolves when the performance data has been dumped.
 */
declare const dumpClientPerformance: {
    (clientId: string, dirName?: string): Promise<void>;
    /**
     * Sets up a listener to dump performance data after execution.
     * Logs the method name if logging is enabled in the global configuration.
     *
     * @param {string} [dirName="./logs/client"] - The directory name where the performance data will be dumped.
     * @returns {Promise<void>} A promise that resolves when the listener has been set up.
     */
    runAfterExecute: (dirName?: any) => Promise<() => void>;
};

/**
 * Adds a new agent to the agent registry. The swarm takes only those agents which was registered
 *
 * @param {IAgentSchema} agentSchema - The schema of the agent to be added.
 * @returns {string} The name of the added agent.
 */
declare const addAgent: (agentSchema: IAgentSchema) => string;

/**
 * Adds a completion engine for agents. Agents could use different models and
 * framewords for completion like: mock, gpt4all, ollama, openai
 *
 * @param {ICompletionSchema} completionSchema - The completion schema to be added.
 * @returns {string} The name of the completion that was added.
 */
declare const addCompletion: (completionSchema: ICompletionSchema) => string;

/**
 * Adds a new swarm to the system. The swarm is a root for starting client session
 *
 * @param {ISwarmSchema} swarmSchema - The schema of the swarm to be added.
 * @returns {string} The name of the added swarm.
 */
declare const addSwarm: (swarmSchema: ISwarmSchema) => string;

/**
 * Adds a new tool for agents in a swarm. Tool should be registered in `addAgent`
 * declaration
 *
 * @param {IAgentTool} toolSchema - The schema of the tool to be added.
 * @returns {string} The name of the tool that was added.
 */
declare const addTool: <T extends any = Record<string, ToolValue>>(storageSchema: IAgentTool<T>) => string;

/**
 * Adds a new state to the state registry. The swarm takes only those states which was registered
 *
 * @param {IStateSchema} stateSchema - The schema of the state to be added.
 * @returns {string} The name of the added state.
 */
declare const addState: <T extends unknown = any>(storageSchema: IStateSchema<T>) => string;

/**
 * Adds a new embedding to the embedding registry. The swarm takes only those embeddings which was registered
 *
 * @param {IEmbeddingSchema} embeddingSchema - The schema of the embedding to be added.
 * @returns {string} The name of the added embedding.
 */
declare const addEmbedding: (embeddingSchema: IEmbeddingSchema) => string;

/**
 * Adds a new storage to the storage registry. The swarm takes only those storages which was registered
 *
 * @param {IStorageSchema} storageSchema - The schema of the storage to be added.
 * @returns {string} The name of the added storage.
 */
declare const addStorage: <T extends IStorageData = IStorageData>(storageSchema: IStorageSchema<T>) => string;

/**
 * Adds a new policy for agents in a swarm. Policy should be registered in `addPolicy`
 * declaration
 *
 * @param {IPolicySchema} policySchema - The schema of the policy to be added.
 * @returns {string} The name of the policy that was added.
 */
declare const addPolicy: (policySchema: IPolicySchema) => string;

/**
 * Commits the tool output to the active agent in a swarm session
 *
 * @param {string} content - The content to be committed.
 * @param {string} clientId - The client ID associated with the session.
 * @param {AgentName} agentName - The name of the agent committing the output.
 * @returns {Promise<void>} - A promise that resolves when the operation is complete.
 */
declare const commitToolOutput: (toolId: string, content: string, clientId: string, agentName: string) => Promise<void>;

/**
 * Commits a system message to the active agent in the swarm.
 *
 * @param {string} content - The content of the system message.
 * @param {string} clientId - The ID of the client.
 * @param {string} agentName - The name of the agent.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitSystemMessage: (content: string, clientId: string, agentName: string) => Promise<void>;

/**
 * Commits flush of agent history
 *
 * @param {string} clientId - The ID of the client.
 * @param {string} agentName - The name of the agent.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitFlush: (clientId: string, agentName: string) => Promise<void>;

/**
 * Commits a user message to the active agent history in as swarm without answer.
 *
 * @param {string} content - The content of the message.
 * @param {string} clientId - The ID of the client.
 * @param {string} agentName - The name of the agent.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitUserMessage: (content: string, clientId: string, agentName: string) => Promise<void>;

/**
 * Commits the tool output to the active agent in a swarm session without checking active agent
 *
 * @param {string} content - The content to be committed.
 * @param {string} clientId - The client ID associated with the session.
 * @returns {Promise<void>} - A promise that resolves when the operation is complete.
 */
declare const commitToolOutputForce: (toolId: string, content: string, clientId: string) => Promise<void>;

/**
 * Commits a system message to the active agent in as swarm without checking active agent.
 *
 * @param {string} content - The content of the system message.
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitSystemMessageForce: (content: string, clientId: string) => Promise<void>;

/**
 * Commits flush of agent history without active agent check
 *
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitFlushForce: (clientId: string) => Promise<void>;

/**
 * Commits a user message to the active agent history in as swarm without answer and checking active agent
 *
 * @param {string} content - The content of the message.
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitUserMessageForce: (content: string, clientId: string) => Promise<void>;

/**
 * Commits an assistant message to the active agent in the swarm.
 *
 * @param {string} content - The content of the assistant message.
 * @param {string} clientId - The ID of the client.
 * @param {string} agentName - The name of the agent.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitAssistantMessage: (content: string, clientId: string, agentName: string) => Promise<void>;

/**
 * Commits an assistant message to the active agent in as swarm without checking active agent.
 *
 * @param {string} content - The content of the assistant message.
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitAssistantMessageForce: (content: string, clientId: string) => Promise<void>;

/**
 * Cancel the await of output by emit of empty string
 *
 * @param {string} clientId - The ID of the client.
 * @param {string} agentName - The name of the agent.
 * @returns {Promise<void>} - A promise that resolves when the output is canceled
 */
declare const cancelOutput: (clientId: string, agentName: string) => Promise<void>;

/**
 * Cancel the await of output by emit of empty string without checking active agent
 *
 * @param {string} clientId - The ID of the client.
 * @param {string} agentName - The name of the agent.
 * @returns {Promise<void>} - A promise that resolves when the output is canceled
 */
declare const cancelOutputForce: (clientId: string) => Promise<void>;

/**
 * Prevent the next tool from being executed
 *
 * @param {string} clientId - The ID of the client.
 * @param {string} agentName - The name of the agent.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitStopTools: (clientId: string, agentName: string) => Promise<void>;

/**
 * Prevent the next tool from being executed without active agent check
 *
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<void>} - A promise that resolves when the message is committed.
 */
declare const commitStopToolsForce: (clientId: string) => Promise<void>;

/**
 * Emits a string constant as the model output without executing incoming message and checking active agent
 * Works only for `makeConnection`
 *
 * @param {string} content - The content to be emitted.
 * @param {string} clientId - The client ID of the session.
 * @param {AgentName} agentName - The name of the agent to emit the content to.
 * @throws Will throw an error if the session mode is not "makeConnection".
 * @returns {Promise<void>} A promise that resolves when the content is emitted.
 */
declare const emitForce: (content: string, clientId: string) => Promise<void>;

/**
 * Send the message to the active agent in the swarm content like it income from client side
 * Should be used to review tool output and initiate conversation from the model side to client
 *
 * Will execute even if the agent is inactive
 *
 * @param {string} content - The content to be executed.
 * @param {string} clientId - The ID of the client requesting execution.
 * @returns {Promise<void>} - A promise that resolves when the execution is complete.
 */
declare const executeForce: (content: string, clientId: string) => Promise<string>;

/**
 * Interface for the parameters of the makeAutoDispose function.
 */
interface IMakeDisposeParams {
    /**
     * Timeout in seconds before auto-dispose is triggered.
     */
    timeoutSeconds: number;
    /**
     * Callback when session is closed
     */
    onDestroy?: (clientId: string, swarmName: SwarmName) => void;
}
/**
 * Creates an auto-dispose mechanism for a client in a swarm.
 *
 * @param {string} clientId - The ID of the client.
 * @param {SwarmName} swarmName - The name of the swarm.
 * @param {Partial<IMakeDisposeParams>} [params={}] - Optional parameters for auto-dispose.
 * @returns {Object} An object with tick and stop methods to control the auto-dispose.
 */
declare const makeAutoDispose: (clientId: string, swarmName: string, args_2?: Partial<IMakeDisposeParams>) => {
    /**
     * Signals that the client is active, resetting the auto-dispose timer.
     */
    tick(): void;
    /**
     * Stops the auto-dispose mechanism.
     */
    destroy(): void;
};

/**
 * Send the message to the active agent in the swarm content like it income from client side
 * Should be used to review tool output and initiate conversation from the model side to client
 *
 * @param {string} content - The content to be executed.
 * @param {string} clientId - The ID of the client requesting execution.
 * @param {AgentName} agentName - The name of the agent executing the command.
 * @returns {Promise<void>} - A promise that resolves when the execution is complete.
 */
declare const execute: (content: string, clientId: string, agentName: string) => Promise<string>;

/**
 * Emits a string constant as the model output without executing incoming message
 * Works only for `makeConnection`
 *
 * @param {string} content - The content to be emitted.
 * @param {string} clientId - The client ID of the session.
 * @param {AgentName} agentName - The name of the agent to emit the content to.
 * @throws Will throw an error if the session mode is not "makeConnection".
 * @returns {Promise<void>} A promise that resolves when the content is emitted.
 */
declare const emit: (content: string, clientId: string, agentName: string) => Promise<void>;

/**
 * Complete the message stateless without append to the chat history
 * Use to prevent model from history overflow while handling storage output
 *
 * @param {string} content - The content to be runned.
 * @param {string} clientId - The ID of the client requesting run.
 * @param {AgentName} agentName - The name of the agent running the command.
 * @returns {Promise<string>} - A promise that resolves the run result
 */
declare const runStateless: (content: string, clientId: string, agentName: string) => Promise<string>;

/**
 * Complete the message stateless without append to the chat history
 * Use to prevent model from history overflow while handling storage output
 *
 * Will run even if the agent is inactive
 *
 * @param {string} content - The content to be runned.
 * @param {string} clientId - The ID of the client requesting run.
 * @returns {Promise<string>} - A promise that resolves the run result
 */
declare const runStatelessForce: (content: string, clientId: string) => Promise<string>;

type SendMessageFn = (outgoing: string) => Promise<void>;
/**
 * A connection factory for a client to a swarm and returns a function to send messages.
 *
 * @param {ReceiveMessageFn} connector - The function to receive messages.
 * @param {string} clientId - The unique identifier of the client.
 * @param {SwarmName} swarmName - The name of the swarm.
 * @returns {SendMessageFn} - A function to send messages to the swarm.
 */
declare const makeConnection: {
    (connector: ReceiveMessageFn, clientId: string, swarmName: SwarmName): SendMessageFn;
    /**
     * A scheduled connection factory for a client to a swarm and returns a function to send messages.
     *
     * @param {ReceiveMessageFn} connector - The function to receive messages.
     * @param {string} clientId - The unique identifier of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {Partial<IMakeConnectionConfig>} [config] - The configuration for scheduling.
     * @returns {SendMessageFn} - A function to send scheduled messages to the swarm.
     */
    scheduled: (connector: ReceiveMessageFn, clientId: string, swarmName: string, args_3?: Partial<IMakeConnectionConfig>) => (content: string) => Promise<void>;
    /**
     * A rate-limited connection factory for a client to a swarm and returns a function to send messages.
     *
     * @param {ReceiveMessageFn} connector - The function to receive messages.
     * @param {string} clientId - The unique identifier of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {Partial<IMakeConnectionConfig>} [config] - The configuration for rate limiting.
     * @param {number} [config.delay=RATE_DELAY] - The delay in milliseconds for rate limiting messages.
     * @returns {SendMessageFn} - A function to send rate-limited messages to the swarm.
     */
    rate: (connector: ReceiveMessageFn, clientId: string, swarmName: string, args_3?: Partial<IMakeConnectionConfig>) => (content: string) => Promise<void | "">;
};
/**
 * Configuration for scheduling messages.
 *
 * @interface IMakeConnectionConfig
 * @property {number} [delay] - The delay in milliseconds for scheduling messages.
 */
interface IMakeConnectionConfig {
    delay?: number;
}

/**
 * The complete function will create a swarm, execute single command and dispose it
 * Best for developer needs like troubleshooting tool execution
 *
 * @param {string} content - The content to process.
 * @param {string} clientId - The client ID.
 * @param {SwarmName} swarmName - The swarm name.
 * @returns {Promise<string>} The result of the complete function.
 */
declare const complete: (content: string, clientId: string, swarmName: string) => Promise<string>;

type TComplete = (content: string) => Promise<string>;
/**
 * Creates a session for the given client and swarm.
 *
 * @param {string} clientId - The ID of the client.
 * @param {SwarmName} swarmName - The name of the swarm.
 * @returns {Object} An object containing the session methods.
 * @returns {TComplete} complete - A function to complete the session with content.
 * @returns {Function} dispose - A function to dispose of the session.
 */
declare const session: {
    (clientId: string, swarmName: SwarmName): {
        /**
         * Completes the session with the given content.
         *
         * @param {string} content - The content to complete the session with.
         * @returns {Promise<string>} A promise that resolves with the result of the session execution.
         */
        complete: TComplete;
        /**
         * Disposes of the session.
         *
         * @returns {Promise<void>} A promise that resolves when the session is disposed.
         */
        dispose: () => Promise<void>;
    };
    /**
     * Creates a scheduled session for the given client and swarm.
     *
     * @param {string} clientId - The ID of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {Partial<ISessionConfig>} [config] - The configuration for the scheduled session.
     * @param {number} [config.delay] - The delay for the scheduled session.
     * @returns {Object} An object containing the scheduled session methods.
     * @returns {TComplete} complete - A function to complete the session with content.
     * @returns {Function} dispose - A function to dispose of the session.
     */
    scheduled(clientId: string, swarmName: SwarmName, { delay }?: Partial<ISessionConfig>): {
        /**
         * Completes the scheduled session with the given content.
         *
         * @param {string} content - The content to complete the session with.
         * @returns {Promise<string>} A promise that resolves with the result of the session execution.
         */
        complete(content: string): Promise<string>;
        /**
         * Disposes of the scheduled session.
         *
         * @returns {Promise<void>} A promise that resolves when the session is disposed.
         */
        dispose(): Promise<void>;
    };
    /**
     * A rate-limited connection factory for a client to a swarm and returns a function to send messages.
     *
     * @param {string} clientId - The unique identifier of the client.
     * @param {SwarmName} swarmName - The name of the swarm.
     * @param {Partial<ISessionConfig>} [config] - The configuration for rate limiting.
     * @param {number} [config.delay=SCHEDULED_DELAY] - The delay in milliseconds for rate limiting messages.
     */
    rate(clientId: string, swarmName: SwarmName, { delay }?: Partial<ISessionConfig>): {
        /**
         * Completes the scheduled session with the given content.
         *
         * @param {string} content - The content to complete the session with.
         * @returns {Promise<string>} A promise that resolves with the result of the session execution.
         */
        complete(content: string): Promise<string>;
        /**
         * Disposes of the scheduled session.
         *
         * @returns {Promise<void>} A promise that resolves when the session is disposed.
         */
        dispose(): Promise<void>;
    };
};
/**
 * Configuration options for a scheduled session.
 *
 * @interface ISessionConfig
 * @property {number} [delay] - The delay for the scheduled session in milliseconds.
 */
interface ISessionConfig {
    delay?: number;
}

/**
 * Disposes the session for a given client with all related swarms and agents.
 *
 * @param {string} clientId - The ID of the client.
 * @param {SwarmName} swarmName - The name of the swarm.
 * @returns {Promise<void>} A promise that resolves when the connection is disposed.
 */
declare const disposeConnection: (clientId: string, swarmName: string, methodName?: any) => Promise<void>;

/**
 * Retrieves the agent name for a given client ID.
 *
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<string>} The name of the agent.
 * @throws Will throw an error if the client ID is invalid or if the swarm validation fails.
 */
declare const getAgentName: (clientId: string) => Promise<string>;

/**
 * Retrieves the history prepared for a specific agent with resque algorithm tweaks
 *
 * @param {string} clientId - The ID of the client.
 * @param {AgentName} agentName - The name of the agent.
 * @returns {Promise<Array>} - A promise that resolves to an array containing the agent's history.
 */
declare const getAgentHistory: (clientId: string, agentName: string) => Promise<IModelMessage[]>;

/**
 * Return the session mode (`"session" | "makeConnection" | "complete"`) for clientId
 *
 * @param {string} clientId - The client ID of the session.
 */
declare const getSessionMode: (clientId: string) => Promise<SessionMode>;

/**
 * Represents the session context.
 *
 * @interface ISessionContext
 * @property {string | null} clientId - The client id, or null if not available.
 * @property {IMethodContext | null} methodContext - The method context, or null if not available.
 * @property {IExecutionContext | null} executionContext - The execution context, or null if not available.
 */
interface ISessionContext {
    clientId: string | null;
    processId: string;
    methodContext: IMethodContext | null;
    executionContext: IExecutionContext | null;
}
/**
 * Retrieves the session context for a given client ID.
 *
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<ISessionContext>} A promise that resolves to the session context.
 */
declare const getSessionContext: () => Promise<ISessionContext>;

/**
 * Retrieves the last message sent by the user from the client's message history.
 *
 * @param {string} clientId - The ID of the client whose message history is being retrieved.
 * @returns {Promise<string | null>} - The content of the last user message, or null if no user message is found.
 */
declare const getLastUserMessage: (clientId: string) => Promise<string>;

/**
 * Retrieves the user history for a given client ID.
 *
 * @param {string} clientId - The ID of the client whose history is to be retrieved.
 * @returns {Promise<Array>} A promise that resolves to an array of history objects filtered by user role.
 */
declare const getUserHistory: (clientId: string) => Promise<IModelMessage[]>;

/**
 * Retrieves the assistant's history for a given client.
 *
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<Array>} - A promise that resolves to an array of history objects where the role is "assistant".
 */
declare const getAssistantHistory: (clientId: string) => Promise<IModelMessage[]>;

/**
 * Retrieves the last message sent by the assistant from the client's message history.
 *
 * @param {string} clientId - The ID of the client whose message history is being retrieved.
 * @returns {Promise<string | null>} - The content of the last assistant message, or null if no user message is found.
 */
declare const getLastAssistantMessage: (clientId: string) => Promise<string>;

/**
 * Retrieves the last message sent by the system from the client's message history.
 *
 * @param {string} clientId - The ID of the client whose message history is being retrieved.
 * @returns {Promise<string | null>} - The content of the last system message, or null if no user message is found.
 */
declare const getLastSystemMessage: (clientId: string) => Promise<string>;

/**
 * Retrieves the raw history as it is for a given client ID without any modifications.
 *
 * @param {string} clientId - The ID of the client whose history is to be retrieved.
 * @returns {Promise<Array>} A promise that resolves to an array containing the raw history.
 */
declare const getRawHistory: (clientId: string, methodName?: any) => Promise<IModelMessage[]>;

/**
 * Emits an event to the swarm bus service.
 *
 * @template T - The type of the payload.
 * @param {string} clientId - The ID of the client emitting the event.
 * @param {T} payload - The payload of the event.
 * @returns {boolean} - Returns true if the event was successfully emitted.
 */
declare const event: <T extends unknown = any>(clientId: string, topicName: string, payload: T) => Promise<void>;

/**
 * Listens for an event on the swarm bus service and executes a callback function when the event is received.
 *
 * @template T - The type of the data payload.
 * @param {string} clientId - The ID of the client to listen for events from.
 * @param {(data: T) => void} fn - The callback function to execute when the event is received. The data payload is passed as an argument to this function.
 */
declare const listenEvent: <T extends unknown = any>(clientId: string, topicName: string, fn: (data: T) => void) => () => void;

/**
 * Listens for an event on the swarm bus service and executes a callback function when the event is received.
 *
 * @template T - The type of the data payload.
 * @param {string} clientId - The ID of the client to listen for events from.
 * @param {(data: T) => void} fn - The callback function to execute when the event is received. The data payload is passed as an argument to this function.
 */
declare const listenEventOnce: <T extends unknown = any>(clientId: string, topicName: string, filterFn: (event: T) => boolean, fn: (data: T) => void) => () => void;

/**
 * Changes the agent for a given client session in swarm.
 * @async
 * @function
 * @param {AgentName} agentName - The name of the agent.
 * @param {string} clientId - The client ID.
 * @returns {Promise<void>} - A promise that resolves when the agent is changed.
 */
declare const changeToAgent: (agentName: string, clientId: string) => Promise<void>;

/**
 * Navigates back to the previous or default agent
 * @async
 * @function
 * @param {string} clientId - The client ID.
 * @returns {Promise<void>} - A promise that resolves when the agent is changed.
 */
declare const changeToPrevAgent: (clientId: string) => Promise<void>;

/**
 * Navigates back to the default agent
 * @async
 * @function
 * @param {string} clientId - The client ID.
 * @returns {Promise<void>} - A promise that resolves when the agent is changed.
 */
declare const changeToDefaultAgent: (clientId: string) => Promise<void>;

/**
 * Hook to subscribe to agent events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to events for.
 * @param {function} fn - The callback function to handle the event.
 */
declare const listenAgentEvent: (clientId: string, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to history events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to.
 * @param {(event: IBusEvent) => void} fn - The callback function to handle the event.
 */
declare const listenHistoryEvent: (clientId: string, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to session events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to session events for.
 * @param {function} fn - The callback function to handle the session events.
 */
declare const listenSessionEvent: (clientId: string, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to state events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to.
 * @param {function} fn - The callback function to handle the event.
 */
declare const listenStateEvent: (clientId: string, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to storage events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to storage events for.
 * @param {function} fn - The callback function to handle the storage event.
 */
declare const listenStorageEvent: (clientId: string, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to swarm events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to events for.
 * @param {(event: IBusEvent) => void} fn - The callback function to handle the event.
 */
declare const listenSwarmEvent: (clientId: string, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to execution events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to events for.
 * @param {function} fn - The callback function to handle the event.
 */
declare const listenExecutionEvent: (clientId: string, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to swarm events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to events for.
 * @param {(event: IBusEvent) => void} fn - The callback function to handle the event.
 */
declare const listenPolicyEvent: (clientId: string, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to agent events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to events for.
 * @param {function} fn - The callback function to handle the event.
 */
declare const listenAgentEventOnce: (clientId: string, filterFn: (event: IBusEvent) => boolean, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to history events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to.
 * @param {(event: IBusEvent) => void} fn - The callback function to handle the event.
 */
declare const listenHistoryEventOnce: (clientId: string, filterFn: (event: IBusEvent) => boolean, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to session events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to session events for.
 * @param {function} fn - The callback function to handle the session events.
 */
declare const listenSessionEventOnce: (clientId: string, filterFn: (event: IBusEvent) => boolean, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to state events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to.
 * @param {function} fn - The callback function to handle the event.
 */
declare const listenStateEventOnce: (clientId: string, filterFn: (event: IBusEvent) => boolean, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to storage events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to storage events for.
 * @param {function} fn - The callback function to handle the storage event.
 */
declare const listenStorageEventOnce: (clientId: string, filterFn: (event: IBusEvent) => boolean, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to swarm events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to events for.
 * @param {(event: IBusEvent) => void} fn - The callback function to handle the event.
 */
declare const listenSwarmEventOnce: (clientId: string, filterFn: (event: IBusEvent) => boolean, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to execution events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to events for.
 * @param {function} fn - The callback function to handle the event.
 */
declare const listenExecutionEventOnce: (clientId: string, filterFn: (event: IBusEvent) => boolean, fn: (event: IBusEvent) => void) => () => void;

/**
 * Hook to subscribe to swarm events for a specific client.
 *
 * @param {string} clientId - The ID of the client to subscribe to events for.
 * @param {(event: IBusEvent) => void} fn - The callback function to handle the event.
 */
declare const listenPolicyEventOnce: (clientId: string, filterFn: (event: IBusEvent) => boolean, fn: (event: IBusEvent) => void) => () => void;

/** @private Symbol for memoizing the waitForInit method in LoggerInstance */
declare const LOGGER_INSTANCE_WAIT_FOR_INIT: unique symbol;
/**
 * Callbacks for managing logger instance lifecycle and log events.
 */
interface ILoggerInstanceCallbacks {
    /**
     * Called when the logger instance is initialized.
     * @param {string} clientId - The client ID.
     */
    onInit(clientId: string): void;
    /**
     * Called when the logger instance is disposed.
     * @param {string} clientId - The client ID.
     */
    onDispose(clientId: string): void;
    /**
     * Called when a log message is recorded.
     * @param {string} clientId - The client ID.
     * @param {string} topic - The log topic.
     * @param {...any[]} args - Additional log arguments.
     */
    onLog(clientId: string, topic: string, ...args: any[]): void;
    /**
     * Called when a debug message is recorded.
     * @param {string} clientId - The client ID.
     * @param {string} topic - The debug topic.
     * @param {...any[]} args - Additional debug arguments.
     */
    onDebug(clientId: string, topic: string, ...args: any[]): void;
    /**
     * Called when an info message is recorded.
     * @param {string} clientId - The client ID.
     * @param {string} topic - The info topic.
     * @param {...any[]} args - Additional info arguments.
     */
    onInfo(clientId: string, topic: string, ...args: any[]): void;
}
/**
 * Interface for logger instances, extending the base ILogger with lifecycle methods.
 * @extends {ILogger}
 */
interface ILoggerInstance extends ILogger {
    /**
     * Initializes the logger instance, optionally waiting for setup.
     * @param {boolean} initial - Whether this is the initial setup (affects caching behavior).
     * @returns {Promise<void> | void} A promise that resolves when initialization is complete, or void if synchronous.
     */
    waitForInit(initial: boolean): Promise<void> | void;
    /**
     * Disposes of the logger instance, cleaning up resources.
     * @returns {Promise<void> | void} A promise that resolves when disposal is complete, or void if synchronous.
     */
    dispose(): Promise<void> | void;
}
/**
 * Interface defining methods for interacting with a logger adapter.
 */
interface ILoggerAdapter {
    /**
     * Logs a message for a client.
     * @param {string} clientId - The client ID.
     * @param {string} topic - The log topic.
     * @param {...any[]} args - Additional log arguments.
     * @returns {Promise<void>} A promise that resolves when the log is recorded.
     */
    log(clientId: string, topic: string, ...args: any[]): Promise<void>;
    /**
     * Logs a debug message for a client.
     * @param {string} clientId - The client ID.
     * @param {string} topic - The debug topic.
     * @param {...any[]} args - Additional debug arguments.
     * @returns {Promise<void>} A promise that resolves when the debug message is recorded.
     */
    debug(clientId: string, topic: string, ...args: any[]): Promise<void>;
    /**
     * Logs an info message for a client.
     * @param {string} clientId - The client ID.
     * @param {string} topic - The info topic.
     * @param {...any[]} args - Additional info arguments.
     * @returns {Promise<void>} A promise that resolves when the info message is recorded.
     */
    info(clientId: string, topic: string, ...args: any[]): Promise<void>;
    /**
     * Disposes of the logger instance for a client.
     * @param {string} clientId - The client ID.
     * @returns {Promise<void>} A promise that resolves when disposal is complete.
     */
    dispose(clientId: string): Promise<void>;
}
/**
 * Interface defining control methods for configuring logger behavior.
 */
interface ILoggerControl {
    /**
     * Sets a common logger adapter for all logging operations.
     * @param {ILogger} logger - The logger instance to use.
     */
    useCommonAdapter(logger: ILogger): void;
    /**
     * Configures client-specific lifecycle callbacks for logger instances.
     * @param {Partial<ILoggerInstanceCallbacks>} Callbacks - The callbacks to apply.
     */
    useClientCallbacks(Callbacks: Partial<ILoggerInstanceCallbacks>): void;
    /**
     * Sets a custom logger instance constructor for client-specific logging.
     * @param {TLoggerInstanceCtor} Ctor - The constructor for creating logger instances.
     */
    useClientAdapter(Ctor: TLoggerInstanceCtor): void;
    /**
     * Logs a message for a specific client using the common adapter.
     * @param {string} clientId - The client ID.
     * @param {string} topic - The log topic.
     * @param {...any[]} args - Additional log arguments.
     * @returns {Promise<void>} A promise that resolves when the log is recorded.
     */
    logClient(clientId: string, topic: string, ...args: any[]): Promise<void>;
    /**
     * Logs an info message for a specific client using the common adapter.
     * @param {string} clientId - The client ID.
     * @param {string} topic - The info topic.
     * @param {...any[]} args - Additional info arguments.
     * @returns {Promise<void>} A promise that resolves when the info message is recorded.
     */
    infoClient(clientId: string, topic: string, ...args: any[]): Promise<void>;
    /**
     * Logs a debug message for a specific client using the common adapter.
     * @param {string} clientId - The client ID.
     * @param {string} topic - The debug topic.
     * @param {...any[]} args - Additional debug arguments.
     * @returns {Promise<void>} A promise that resolves when the debug message is recorded.
     */
    debugClient(clientId: string, topic: string, ...args: any[]): Promise<void>;
}
/**
 * Constructor type for creating logger instances.
 * @typedef {new (clientId: string, callbacks: Partial<ILoggerInstanceCallbacks>) => ILoggerInstance} TLoggerInstanceCtor
 */
type TLoggerInstanceCtor = new (clientId: string, callbacks: Partial<ILoggerInstanceCallbacks>) => ILoggerInstance;
/**
 * Manages logging operations for a specific client, with customizable callbacks.
 * @implements {ILoggerInstance}
 */
declare class LoggerInstance implements ILoggerInstance {
    readonly clientId: string;
    readonly callbacks: Partial<ILoggerInstanceCallbacks>;
    /**
     * Creates a new logger instance.
     * @param {string} clientId - The client ID associated with this logger.
     * @param {Partial<ILoggerInstanceCallbacks>} callbacks - Optional lifecycle callbacks.
     */
    constructor(clientId: string, callbacks: Partial<ILoggerInstanceCallbacks>);
    /**
     * Memoized initialization function to ensure it runs only once.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     * @private
     */
    private [LOGGER_INSTANCE_WAIT_FOR_INIT];
    /**
     * Initializes the logger instance, invoking the onInit callback if provided.
     * @param {boolean} [initial] - Whether this is the initial setup (unused in this implementation).
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    waitForInit(): Promise<void>;
    /**
     * Logs a message to the console (if enabled) and invokes the onLog callback.
     * @param {string} topic - The topic of the log message.
     * @param {...any[]} args - Additional arguments to log.
     */
    log(topic: string, ...args: any[]): void;
    /**
     * Logs a debug message to the console (if enabled) and invokes the onDebug callback.
     * @param {string} topic - The topic of the debug message.
     * @param {...any[]} args - Additional arguments to debug log.
     */
    debug(topic: string, ...args: any[]): void;
    /**
     * Logs an info message to the console (if enabled) and invokes the onInfo callback.
     * @param {string} topic - The topic of the info message.
     * @param {...any[]} args - Additional arguments to info log.
     */
    info(topic: string, ...args: any[]): void;
    /**
     * Disposes of the logger instance, invoking the onDispose callback if provided.
     * @returns {void} Synchronous operation with no return value.
     */
    dispose(): void;
}
/**
 * Exported Logger Control interface for configuring logger behavior.
 * @type {ILoggerControl}
 */
declare const Logger: ILoggerControl;

/**
 * Global configuration object defining default settings and behaviors for the swarm system.
 * Centralizes constants and functions used across components like ClientAgent (e.g., tool handling, logging, history), customizable via setConfig.
 * Influences workflows such as message processing (e.g., CC_EMPTY_OUTPUT_PLACEHOLDERS in RUN_FN), tool call recovery (e.g., CC_RESQUE_STRATEGY in _resurrectModel), and logging (e.g., CC_LOGGER_ENABLE_DEBUG).
 * @type {typeof GLOBAL_CONFIG}
 */
declare const GLOBAL_CONFIG: {
    CC_TOOL_CALL_EXCEPTION_FLUSH_PROMPT: string;
    CC_TOOL_CALL_EXCEPTION_RECOMPLETE_PROMPT: string;
    CC_EMPTY_OUTPUT_PLACEHOLDERS: string[];
    CC_KEEP_MESSAGES: number;
    CC_MAX_TOOL_CALLS: number;
    CC_AGENT_MAP_TOOLS: (tool: IToolCall[], clientId: string, agentName: AgentName) => IToolCall[] | Promise<IToolCall[]>;
    CC_GET_AGENT_HISTORY_ADAPTER: (clientId: string, agentName: AgentName) => IHistoryAdapter;
    CC_GET_CLIENT_LOGGER_ADAPTER: () => ILoggerAdapter;
    CC_SWARM_AGENT_CHANGED: (clientId: string, agentName: AgentName, swarmName: SwarmName) => Promise<void>;
    CC_SWARM_DEFAULT_AGENT: (clientId: string, swarmName: SwarmName, defaultAgent: AgentName) => Promise<AgentName>;
    CC_SWARM_DEFAULT_STACK: (clientId: string, swarmName: SwarmName) => Promise<AgentName[]>;
    CC_SWARM_STACK_CHANGED: (clientId: string, navigationStack: AgentName[], swarmName: SwarmName) => Promise<void>;
    CC_AGENT_DEFAULT_VALIDATION: (output: string) => Promise<string | null>;
    CC_AGENT_HISTORY_FILTER: (agentName: AgentName) => (message: IModelMessage) => boolean;
    CC_AGENT_OUTPUT_TRANSFORM: (input: string) => string;
    CC_AGENT_OUTPUT_MAP: (message: IModelMessage) => IModelMessage | Promise<IModelMessage>;
    CC_AGENT_SYSTEM_PROMPT: string[];
    CC_AGENT_DISALLOWED_TAGS: string[];
    CC_AGENT_DISALLOWED_SYMBOLS: string[];
    CC_STORAGE_SEARCH_SIMILARITY: number;
    CC_STORAGE_SEARCH_POOL: number;
    CC_LOGGER_ENABLE_INFO: boolean;
    CC_LOGGER_ENABLE_DEBUG: boolean;
    CC_LOGGER_ENABLE_LOG: boolean;
    CC_LOGGER_ENABLE_CONSOLE: boolean;
    CC_RESQUE_STRATEGY: "flush" | "recomplete" | "custom";
    CC_NAME_TO_TITLE: (name: string) => string;
    CC_FN_PLANTUML: (uml: string) => Promise<string>;
    CC_PROCESS_UUID: string;
    CC_BANHAMMER_PLACEHOLDER: string;
    CC_TOOL_CALL_EXCEPTION_CUSTOM_FUNCTION: (clientId: string, agentName: AgentName) => Promise<IModelMessage | null>;
    CC_PERSIST_ENABLED_BY_DEFAULT: boolean;
    CC_AUTOBAN_ENABLED_BY_DEFAULT: boolean;
    CC_DEFAULT_STATE_SET: <T = any>(state: T, clientId: string, stateName: StateName) => Promise<void>;
    CC_DEFAULT_STATE_GET: <T = any>(clientId: string, stateName: StateName, defaultState: T) => Promise<T>;
    CC_DEFAULT_STORAGE_GET: <T extends IStorageData = IStorageData>(clientId: string, storageName: StorageName, defaultValue: T[]) => Promise<T[]>;
    CC_DEFAULT_STORAGE_SET: <T extends IStorageData = IStorageData>(data: T[], clientId: string, storageName: StorageName) => Promise<void>;
    CC_SKIP_POSIX_RENAME: boolean;
};
/**
 * Function to update the GLOBAL_CONFIG object with custom settings at runtime.
 * Merges provided config overrides into GLOBAL_CONFIG, allowing dynamic adjustment of system behavior (e.g., enabling CC_LOGGER_ENABLE_DEBUG for ClientAgent).
 * @param {Partial<typeof GLOBAL_CONFIG>} config - The partial configuration object to apply.
 * @returns {void}
 * @example
 * setConfig({ CC_LOGGER_ENABLE_DEBUG: true }); // Enables debug logging
 */
declare const setConfig: (config: Partial<typeof GLOBAL_CONFIG>) => void;

/**
 * Utility class providing methods to manage client bans within a swarm policy context.
 * All methods validate inputs and execute within a context for logging and tracking.
 */
declare class PolicyUtils {
    /**
     * Bans a client under a specific policy within a swarm.
     * Validates the client, swarm, and policy before delegating to the policy service.
     * @param {Object} payload - The payload containing ban details.
     * @param {string} payload.clientId - The client ID to ban.
     * @param {SwarmName} payload.swarmName - The name of the swarm.
     * @param {PolicyName} payload.policyName - The name of the policy to enforce the ban.
     * @returns {Promise<void>} A promise that resolves when the ban is applied.
     * @throws {Error} If validation fails or the policy service encounters an error.
     */
    banClient: (payload: {
        clientId: string;
        swarmName: SwarmName;
        policyName: PolicyName;
    }) => Promise<void>;
    /**
     * Unbans a client under a specific policy within a swarm.
     * Validates the client, swarm, and policy before delegating to the policy service.
     * @param {Object} payload - The payload containing unban details.
     * @param {string} payload.clientId - The client ID to unban.
     * @param {SwarmName} payload.swarmName - The name of the swarm.
     * @param {PolicyName} payload.policyName - The name of the policy to lift the ban from.
     * @returns {Promise<void>} A promise that resolves when the unban is applied.
     * @throws {Error} If validation fails or the policy service encounters an error.
     */
    unbanClient: (payload: {
        clientId: string;
        swarmName: SwarmName;
        policyName: PolicyName;
    }) => Promise<void>;
    /**
     * Checks if a client is banned under a specific policy within a swarm.
     * Validates the client, swarm, and policy before querying the policy service.
     * @param {Object} payload - The payload containing ban check details.
     * @param {string} payload.clientId - The client ID to check.
     * @param {SwarmName} payload.swarmName - The name of the swarm.
     * @param {PolicyName} payload.policyName - The name of the policy to check against.
     * @returns {Promise<boolean>} A promise resolving to true if the client is banned, false otherwise.
     * @throws {Error} If validation fails or the policy service encounters an error.
     */
    hasBan: (payload: {
        clientId: string;
        swarmName: SwarmName;
        policyName: PolicyName;
    }) => Promise<boolean>;
}
/**
 * Singleton instance of PolicyUtils for managing client bans and policy enforcement.
 * @type {PolicyUtils}
 */
declare const Policy: PolicyUtils;

/**
 * Type definition for a state object, mapping IState keys to unknown values.
 * @typedef {{ [key in keyof IState]: unknown }} TState
 */
type TState = {
    [key in keyof IState]: unknown;
};
/**
 * Utility class for managing client-specific state within an agent swarm.
 * Provides methods to get, set, and clear state data for specific clients, agents, and state names,
 * interfacing with the swarm's state service and enforcing agent-state registration.
 * @implements {TState}
 */
declare class StateUtils implements TState {
    /**
     * Retrieves the state data for a given client, agent, and state name.
     * Validates the client session and agent-state registration before querying the state service.
     * Executes within a context for logging.
     * @template T - The type of the state data to retrieve, defaults to any.
     * @param {Object} payload - The payload containing client, agent, and state information.
     * @param {string} payload.clientId - The ID of the client whose state is being retrieved.
     * @param {AgentName} payload.agentName - The name of the agent associated with the state.
     * @param {StateName} payload.stateName - The name of the state to retrieve.
     * @returns {Promise<T>} A promise resolving to the state data associated with the client and state name.
     * @throws {Error} If the client session is invalid, the state is not registered in the agent, or the state service encounters an error.
     */
    getState: <T extends unknown = any>(payload: {
        clientId: string;
        agentName: AgentName;
        stateName: StateName;
    }) => Promise<T>;
    /**
     * Sets the state data for a given client, agent, and state name.
     * Accepts either a direct value or a function that computes the new state based on the previous state.
     * Validates the client session and agent-state registration before updating via the state service.
     * Executes within a context for logging.
     * @template T - The type of the state data to set, defaults to any.
     * @param {T | ((prevState: T) => Promise<T>)} dispatchFn - The new state value or an async function that takes the previous state and returns the new state.
     * @param {Object} payload - The payload containing client, agent, and state information.
     * @param {string} payload.clientId - The ID of the client whose state is being updated.
     * @param {AgentName} payload.agentName - The name of the agent associated with the state.
     * @param {StateName} payload.stateName - The name of the state to update.
     * @returns {Promise<void>} A promise that resolves when the state is successfully updated.
     * @throws {Error} If the client session is invalid, the state is not registered in the agent, or the state service encounters an error.
     */
    setState: <T extends unknown = any>(dispatchFn: T | ((prevState: T) => Promise<T>), payload: {
        clientId: string;
        agentName: AgentName;
        stateName: StateName;
    }) => Promise<void>;
    /**
     * Clears the state data for a given client, agent, and state name, resetting it to its initial value.
     * Validates the client session and agent-state registration before clearing via the state service.
     * Executes within a context for logging.
     * @template T - The type of the state data, defaults to any (unused in return).
     * @param {Object} payload - The payload containing client, agent, and state information.
     * @param {string} payload.clientId - The ID of the client whose state is being cleared.
     * @param {AgentName} payload.agentName - The name of the agent associated with the state.
     * @param {StateName} payload.stateName - The name of the state to clear.
     * @returns {Promise<void>} A promise that resolves when the state is successfully cleared.
     * @throws {Error} If the client session is invalid, the state is not registered in the agent, or the state service encounters an error.
     */
    clearState: <T extends unknown = any>(payload: {
        clientId: string;
        agentName: AgentName;
        stateName: StateName;
    }) => Promise<T>;
}
/**
 * Singleton instance of StateUtils for managing client-specific state operations.
 * @type {StateUtils}
 */
declare const State: StateUtils;

/**
 * Type definition for a shared state object, mapping IState keys to unknown values.
 * @typedef {{ [key in keyof IState]: unknown }} TSharedState
 */
type TSharedState = {
    [key in keyof IState]: unknown;
};
/**
 * Utility class for managing shared state within an agent swarm.
 * Provides methods to get, set, and clear state data for specific state names, interfacing with the swarm's shared state service.
 * @implements {TSharedState}
 */
declare class SharedStateUtils implements TSharedState {
    /**
     * Retrieves the shared state data for a given state name.
     * Executes within a context for logging and delegates to the shared state service.
     * @template T - The type of the state data to retrieve, defaults to any.
     * @param {StateName} stateName - The name of the state to retrieve.
     * @returns {Promise<T>} A promise resolving to the state data associated with the state name.
     * @throws {Error} If the state name is not registered in the agent or the shared state service encounters an error.
     */
    getState: <T extends unknown = any>(stateName: StateName) => Promise<T>;
    /**
     * Sets the shared state data for a given state name.
     * Accepts either a direct value or a function that computes the new state based on the previous state.
     * Executes within a context for logging and delegates to the shared state service.
     * @template T - The type of the state data to set, defaults to any.
     * @param {T | ((prevSharedState: T) => Promise<T>)} dispatchFn - The new state value or an async function that takes the previous state and returns the new state.
     * @param {StateName} stateName - The name of the state to update.
     * @returns {Promise<void>} A promise that resolves when the state is successfully updated.
     * @throws {Error} If the state name is not registered in the agent or the shared state service encounters an error.
     */
    setState: <T extends unknown = any>(dispatchFn: T | ((prevSharedState: T) => Promise<T>), stateName: StateName) => Promise<void>;
    /**
     * Clears the shared state for a given state name, resetting it to its initial value.
     * Executes within a context for logging and delegates to the shared state service.
     * @template T - The type of the state data, defaults to any (unused in return).
     * @param {StateName} stateName - The name of the state to clear.
     * @returns {Promise<void>} A promise that resolves when the state is successfully cleared.
     * @throws {Error} If the state name is not registered in the agent or the shared state service encounters an error.
     */
    clearState: <T extends unknown = any>(stateName: StateName) => Promise<T>;
}
/**
 * Singleton instance of SharedStateUtils for managing shared state operations.
 * @type {SharedStateUtils}
 */
declare const SharedState: SharedStateUtils;

/**
 * Type definition for a storage object, mapping IStorage keys to unknown values.
 * @typedef {{ [key in keyof IStorage]: unknown }} TStorage
 */
type TStorage = {
    [key in keyof IStorage]: unknown;
};
/**
 * Utility class for managing client-specific storage within an agent swarm.
 * Provides methods to manipulate and query storage data for specific clients, agents, and storage names,
 * interfacing with the swarm's storage service and enforcing agent-storage registration.
 * @implements {TStorage}
 */
declare class StorageUtils implements TStorage {
    /**
     * Retrieves a specified number of items from storage matching a search query for a given client and agent.
     * Validates the client session, storage name, and agent-storage registration before querying the storage service.
     * Executes within a context for logging.
     * @template T - The type of the storage data items, defaults to IStorageData.
     * @param {Object} payload - The payload containing search, client, agent, and storage details.
     * @param {string} payload.search - The search query to filter items.
     * @param {number} payload.total - The maximum number of items to retrieve.
     * @param {string} payload.clientId - The ID of the client whose storage is being queried.
     * @param {AgentName} payload.agentName - The name of the agent associated with the storage.
     * @param {StorageName} payload.storageName - The name of the storage to query.
     * @param {number} [payload.score] - Optional relevance score threshold for filtering items.
     * @returns {Promise<T[]>} A promise resolving to an array of matching storage items.
     * @throws {Error} If the client session is invalid, storage validation fails, the storage is not registered in the agent, or the storage service encounters an error.
     */
    take: <T extends IStorageData = IStorageData>(payload: {
        search: string;
        total: number;
        clientId: string;
        agentName: AgentName;
        storageName: StorageName;
        score?: number;
    }) => Promise<T[]>;
    /**
     * Inserts or updates an item in the storage for a given client and agent.
     * Validates the client session, storage name, and agent-storage registration before updating via the storage service.
     * Executes within a context for logging.
     * @template T - The type of the storage data item, defaults to IStorageData.
     * @param {Object} payload - The payload containing item, client, agent, and storage details.
     * @param {T} payload.item - The item to upsert into the storage.
     * @param {string} payload.clientId - The ID of the client whose storage is being updated.
     * @param {AgentName} payload.agentName - The name of the agent associated with the storage.
     * @param {StorageName} payload.storageName - The name of the storage to update.
     * @returns {Promise<void>} A promise that resolves when the upsert operation is complete.
     * @throws {Error} If the client session is invalid, storage validation fails, the storage is not registered in the agent, or the storage service encounters an error.
     */
    upsert: <T extends IStorageData = IStorageData>(payload: {
        item: T;
        clientId: string;
        agentName: AgentName;
        storageName: StorageName;
    }) => Promise<void>;
    /**
     * Removes an item from the storage by its ID for a given client and agent.
     * Validates the client session, storage name, and agent-storage registration before removing via the storage service.
     * Executes within a context for logging.
     * @param {Object} payload - The payload containing item ID, client, agent, and storage details.
     * @param {IStorageData["id"]} payload.itemId - The ID of the item to remove.
     * @param {string} payload.clientId - The ID of the client whose storage is being modified.
     * @param {AgentName} payload.agentName - The name of the agent associated with the storage.
     * @param {StorageName} payload.storageName - The name of the storage to modify.
     * @returns {Promise<void>} A promise that resolves when the removal operation is complete.
     * @throws {Error} If the client session is invalid, storage validation fails, the storage is not registered in the agent, or the storage service encounters an error.
     */
    remove: (payload: {
        itemId: IStorageData["id"];
        clientId: string;
        agentName: AgentName;
        storageName: StorageName;
    }) => Promise<void>;
    /**
     * Retrieves an item from the storage by its ID for a given client and agent.
     * Validates the storage name and agent-storage registration before querying the storage service.
     * Executes within a context for logging.
     * @template T - The type of the storage data item, defaults to IStorageData.
     * @param {Object} payload - The payload containing item ID, client, agent, and storage details.
     * @param {IStorageData["id"]} payload.itemId - The ID of the item to retrieve.
     * @param {string} payload.clientId - The ID of the client whose storage is being queried.
     * @param {AgentName} payload.agentName - The name of the agent associated with the storage.
     * @param {StorageName} payload.storageName - The name of the storage to query.
     * @returns {Promise<T | null>} A promise resolving to the item if found, or null if not found.
     * @throws {Error} If storage validation fails, the storage is not registered in the agent, or the storage service encounters an error.
     */
    get: <T extends IStorageData = IStorageData>(payload: {
        itemId: IStorageData["id"];
        clientId: string;
        agentName: AgentName;
        storageName: StorageName;
    }) => Promise<T | null>;
    /**
     * Lists all items in the storage for a given client and agent, optionally filtered by a predicate.
     * Validates the storage name and agent-storage registration before querying the storage service.
     * Executes within a context for logging.
     * @template T - The type of the storage data items, defaults to IStorageData.
     * @param {Object} payload - The payload containing client, agent, and storage details.
     * @param {string} payload.clientId - The ID of the client whose storage is being queried.
     * @param {AgentName} payload.agentName - The name of the agent associated with the storage.
     * @param {StorageName} payload.storageName - The name of the storage to query.
     * @param {(item: T) => boolean} [payload.filter] - Optional function to filter items; only items returning true are included.
     * @returns {Promise<T[]>} A promise resolving to an array of storage items.
     * @throws {Error} If storage validation fails, the storage is not registered in the agent, or the storage service encounters an error.
     */
    list: <T extends IStorageData = IStorageData>(payload: {
        clientId: string;
        agentName: AgentName;
        storageName: StorageName;
        filter?: (item: T) => boolean;
    }) => Promise<T[]>;
    /**
     * Clears all items from the storage for a given client and agent.
     * Validates the storage name and agent-storage registration before clearing via the storage service.
     * Executes within a context for logging.
     * @param {Object} payload - The payload containing client, agent, and storage details.
     * @param {string} payload.clientId - The ID of the client whose storage is being cleared.
     * @param {AgentName} payload.agentName - The name of the agent associated with the storage.
     * @param {StorageName} payload.storageName - The name of the storage to clear.
     * @returns {Promise<void>} A promise that resolves when the clear operation is complete.
     * @throws {Error} If storage validation fails, the storage is not registered in the agent, or the storage service encounters an error.
     */
    clear: (payload: {
        clientId: string;
        agentName: AgentName;
        storageName: StorageName;
    }) => Promise<void>;
}
/**
 * Singleton instance of StorageUtils for managing client-specific storage operations.
 * @type {StorageUtils}
 */
declare const Storage: StorageUtils;

/**
 * Type definition for a shared storage object, mapping IStorage keys to unknown values.
 * @typedef {{ [key in keyof IStorage]: unknown }} TSharedStorage
 */
type TSharedStorage = {
    [key in keyof IStorage]: unknown;
};
/**
 * Utility class for managing shared storage within an agent swarm.
 * Provides methods to manipulate and query storage data, interfacing with the swarm's shared storage service.
 * @implements {TSharedStorage}
 */
declare class SharedStorageUtils implements TSharedStorage {
    /**
     * Retrieves a specified number of items from storage matching a search query.
     * Executes within a context for logging and validation, ensuring the storage name is valid.
     * @template T - The type of the storage data items, defaults to IStorageData.
     * @param {Object} payload - The payload containing search and storage details.
     * @param {string} payload.search - The search query to filter items.
     * @param {number} payload.total - The maximum number of items to retrieve.
     * @param {StorageName} payload.storageName - The name of the storage to query.
     * @param {number} [payload.score] - Optional relevance score threshold for filtering items.
     * @returns {Promise<T[]>} A promise resolving to an array of matching storage items.
     * @throws {Error} If storage validation fails or the shared storage service encounters an error.
     */
    take: <T extends IStorageData = IStorageData>(payload: {
        search: string;
        total: number;
        storageName: StorageName;
        score?: number;
    }) => Promise<T[]>;
    /**
     * Inserts or updates an item in the storage.
     * Executes within a context for logging and validation, ensuring the storage name is valid.
     * @template T - The type of the storage data item, defaults to IStorageData.
     * @param {T} item - The item to upsert into the storage.
     * @param {StorageName} storageName - The name of the storage to update.
     * @returns {Promise<void>} A promise that resolves when the upsert operation is complete.
     * @throws {Error} If storage validation fails or the shared storage service encounters an error.
     */
    upsert: <T extends IStorageData = IStorageData>(item: T, storageName: StorageName) => Promise<void>;
    /**
     * Removes an item from the storage by its ID.
     * Executes within a context for logging and validation, ensuring the storage name is valid.
     * @param {IStorageData["id"]} itemId - The ID of the item to remove.
     * @param {StorageName} storageName - The name of the storage to modify.
     * @returns {Promise<void>} A promise that resolves when the removal operation is complete.
     * @throws {Error} If storage validation fails or the shared storage service encounters an error.
     */
    remove: (itemId: IStorageData["id"], storageName: StorageName) => Promise<void>;
    /**
     * Retrieves an item from the storage by its ID.
     * Executes within a context for logging and validation, ensuring the storage name is valid.
     * @template T - The type of the storage data item, defaults to IStorageData.
     * @param {IStorageData["id"]} itemId - The ID of the item to retrieve.
     * @param {StorageName} storageName - The name of the storage to query.
     * @returns {Promise<T | null>} A promise resolving to the item if found, or null if not found.
     * @throws {Error} If storage validation fails or the shared storage service encounters an error.
     */
    get: <T extends IStorageData = IStorageData>(itemId: IStorageData["id"], storageName: StorageName) => Promise<T | null>;
    /**
     * Lists all items in the storage, optionally filtered by a predicate.
     * Executes within a context for logging and validation, ensuring the storage name is valid.
     * @template T - The type of the storage data items, defaults to IStorageData.
     * @param {StorageName} storageName - The name of the storage to query.
     * @param {(item: T) => boolean} [filter] - Optional function to filter items; only items returning true are included.
     * @returns {Promise<T[]>} A promise resolving to an array of storage items.
     * @throws {Error} If storage validation fails or the shared storage service encounters an error.
     */
    list: <T extends IStorageData = IStorageData>(storageName: StorageName, filter?: (item: T) => boolean) => Promise<T[]>;
    /**
     * Clears all items from the storage.
     * Executes within a context for logging and validation, ensuring the storage name is valid.
     * @param {StorageName} storageName - The name of the storage to clear.
     * @returns {Promise<void>} A promise that resolves when the clear operation is complete.
     * @throws {Error} If storage validation fails or the shared storage service encounters an error.
     */
    clear: (storageName: string) => Promise<void>;
}
/**
 * Singleton instance of SharedStorageUtils for managing shared storage operations.
 * @type {SharedStorageUtils}
 */
declare const SharedStorage: SharedStorageUtils;

/**
 * Utility class for managing schema-related operations, including session memory access and data serialization.
 * Provides methods to read/write client session memory and serialize objects into formatted strings.
 */
declare class SchemaUtils {
    /**
     * Writes a value to the session memory for a given client.
     * Executes within a context for logging and validation, ensuring the client session is valid.
     * @template T - The type of the value to write, must extend object.
     * @param {string} clientId - The ID of the client whose session memory will be updated.
     * @param {T} value - The value to write to the session memory, typically an object.
     * @returns {T} The value written to the session memory, as returned by the memory schema service.
     * @throws {Error} If session validation fails or the memory schema service encounters an error.
     */
    writeSessionMemory: <T extends object = object>(clientId: string, value: T) => T;
    /**
     * Reads a value from the session memory for a given client.
     * Executes within a context for logging and validation, ensuring the client session is valid.
     * @template T - The type of the value to read, must extend object.
     * @param {string} clientId - The ID of the client whose session memory will be read.
     * @returns {T} The value read from the session memory, as returned by the memory schema service.
     * @throws {Error} If session validation fails or the memory schema service encounters an error.
     */
    readSessionMemory: <T extends object = object>(clientId: string) => T;
    /**
     * Serializes an object or array of objects into a formatted string.
     * Flattens nested objects and applies optional key/value mapping functions for formatting.
     * @template T - The type of the object(s) to serialize, defaults to any.
     * @param {T[] | T} data - The data to serialize, either a single object or an array of objects.
     * @param {Object} [map] - Optional configuration for mapping keys and values.
     * @param {(key: string) => string} [map.mapKey=GLOBAL_CONFIG.CC_NAME_TO_TITLE] - Function to transform property keys.
     * @param {(key: string, value: string) => string} [map.mapValue] - Function to transform property values, defaults to truncating at 50 characters.
     * @returns {string} A formatted string representation of the data, with key-value pairs separated by newlines.
     */
    serialize: <T extends object = any>(data: T[] | T, map?: {
        mapKey?: typeof GLOBAL_CONFIG.CC_NAME_TO_TITLE;
        mapValue?: (key: string, value: string) => string;
    }) => string;
}
/**
 * Singleton instance of SchemaUtils for managing schema operations.
 * @type {SchemaUtils}
 */
declare const Schema: SchemaUtils;

/**
 * Type definition for a function that handles completion requests to an AI provider.
 * @callback TCompleteFn
 * @param {ICompletionArgs} args - The arguments for the completion request.
 * @returns {Promise<IModelMessage>} The response from the completion endpoint in `agent-swarm-kit` format.
 */
type TCompleteFn = (args: ICompletionArgs) => Promise<IModelMessage>;
/**
 * Utility class providing adapter functions for interacting with various AI completion providers.
 */
declare class AdapterUtils {
    /**
     * Creates a function to interact with OpenAI's chat completions API.
     * @param {any} openai - The OpenAI client instance.
     * @param {string} [model="gpt-3.5-turbo"] - The model to use for completions (defaults to "gpt-3.5-turbo").
     * @param {{ type: string }} [response_format] - Optional response format configuration (e.g., `{ type: "json_object" }`).
     * @returns {TCompleteFn} A function that processes completion arguments and returns a response from OpenAI.
     */
    fromOpenAI: (openai: any, model?: string, response_format?: {
        type: string;
    }) => TCompleteFn;
    /**
     * Creates a function to interact with LMStudio's chat completions API.
     * @param {any} openai - The LMStudio client instance (compatible with OpenAI-style API).
     * @param {string} [model="saiga_yandexgpt_8b_gguf"] - The model to use for completions (defaults to "saiga_yandexgpt_8b_gguf").
     * @param {{ type: string }} [response_format] - Optional response format configuration (e.g., `{ type: "json_object" }`).
     * @returns {TCompleteFn} A function that processes completion arguments and returns a response from LMStudio.
     */
    fromLMStudio: (openai: any, model?: string, response_format?: {
        type: string;
    }) => TCompleteFn;
    /**
     * Creates a function to interact with Ollama's chat completions API.
     * @param {any} ollama - The Ollama client instance.
     * @param {string} [model="nemotron-mini:4b"] - The model to use for completions (defaults to "nemotron-mini:4b").
     * @param {string} [tool_call_protocol=TOOL_PROTOCOL_PROMPT] - The protocol prompt for tool calls (defaults to TOOL_PROTOCOL_PROMPT).
     * @returns {TCompleteFn} A function that processes completion arguments and returns a response from Ollama.
     */
    fromOllama: (ollama: any, model?: string, tool_call_protocol?: string) => TCompleteFn;
}
/**
 * Singleton instance of AdapterUtils for interacting with AI completion providers.
 * @type {AdapterUtils}
 */
declare const Adapter: AdapterUtils;

/**
 * A higher-order function that ensures execution outside of existing method and execution contexts.
 *
 * @template T - Generic type extending any function
 * @param {T} run - The function to be executed outside of existing contexts
 * @returns {(...args: Parameters<T>) => ReturnType<T>} A wrapped function that executes outside of any existing contexts
 *
 * @example
 * const myFunction = (arg: string) => console.log(arg);
 * const contextSafeFunction = beginContext(myFunction);
 * contextSafeFunction('test'); // Executes myFunction outside of any existing contexts
 *
 * @remarks
 * This utility function checks for both MethodContext and ExecutionContext.
 * If either context exists, the provided function will be executed outside of those contexts.
 * This is useful for ensuring clean execution environments for certain operations.
 */
declare const beginContext: <T extends (...args: any[]) => any>(run: T) => ((...args: Parameters<T>) => ReturnType<T>);

declare const Utils: {
    PersistStateUtils: typeof PersistStateUtils;
    PersistSwarmUtils: typeof PersistSwarmUtils;
    PersistStorageUtils: typeof PersistStorageUtils;
};

export { Adapter, type EventSource, ExecutionContextService, History, HistoryMemoryInstance, HistoryPersistInstance, type IAgentSchema, type IAgentTool, type IBaseEvent, type IBusEvent, type IBusEventContext, type ICompletionArgs, type ICompletionSchema, type ICustomEvent, type IEmbeddingSchema, type IHistoryAdapter, type IHistoryControl, type IHistoryInstance, type IHistoryInstanceCallbacks, type IIncomingMessage, type ILoggerAdapter, type ILoggerInstance, type ILoggerInstanceCallbacks, type IMakeConnectionConfig, type IMakeDisposeParams, type IModelMessage, type IOutgoingMessage, type IPersistBase, type IPolicySchema, type ISessionConfig, type IStateSchema, type IStorageSchema, type ISwarmSchema, type ITool, type IToolCall, Logger, LoggerInstance, MethodContextService, PersistBase, PersistList, PersistState, PersistStorage, PersistSwarm, Policy, type ReceiveMessageFn, Schema, type SendMessageFn$1 as SendMessageFn, SharedState, SharedStorage, State, Storage, type THistoryInstanceCtor, type TPersistBaseCtor, Utils, addAgent, addCompletion, addEmbedding, addPolicy, addState, addStorage, addSwarm, addTool, beginContext, cancelOutput, cancelOutputForce, changeToAgent, changeToDefaultAgent, changeToPrevAgent, commitAssistantMessage, commitAssistantMessageForce, commitFlush, commitFlushForce, commitStopTools, commitStopToolsForce, commitSystemMessage, commitSystemMessageForce, commitToolOutput, commitToolOutputForce, commitUserMessage, commitUserMessageForce, complete, disposeConnection, dumpAgent, dumpClientPerformance, dumpDocs, dumpPerfomance, dumpSwarm, emit, emitForce, event, execute, executeForce, getAgentHistory, getAgentName, getAssistantHistory, getLastAssistantMessage, getLastSystemMessage, getLastUserMessage, getRawHistory, getSessionContext, getSessionMode, getUserHistory, listenAgentEvent, listenAgentEventOnce, listenEvent, listenEventOnce, listenExecutionEvent, listenExecutionEventOnce, listenHistoryEvent, listenHistoryEventOnce, listenPolicyEvent, listenPolicyEventOnce, listenSessionEvent, listenSessionEventOnce, listenStateEvent, listenStateEventOnce, listenStorageEvent, listenStorageEventOnce, listenSwarmEvent, listenSwarmEventOnce, makeAutoDispose, makeConnection, runStateless, runStatelessForce, session, setConfig, swarm };
